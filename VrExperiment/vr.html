<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Basic WebVR Pickup â€” Orange Ball</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- A-Frame (WebXR-enabled). Works on desktop & VR headsets. -->
  <script src="https://unpkg.com/aframe@1.5.0/dist/aframe.min.js"></script>
  <style>
    html, body { margin: 0; height: 100%; background:#000; }
    #hud {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 12px; padding: 8px 12px; border-radius: 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      background: rgba(0,0,0,0.5); color: #fff; font-size: 14px; line-height: 1.2;
      user-select: none; pointer-events: none; white-space: pre-line; text-align: center;
    }
  </style>
</head>
<body>
  <div id="hud">Desktop: point with mouse, press & hold to pick up, release to drop.
VR: point controller ray at the ball, hold trigger to pick up, release to drop.</div>

  <a-scene renderer="antialias: true; colorManagement: true" background="color: #88caff">
    <!-- Lights -->
    <a-entity light="type: ambient; color: #fff; intensity: 0.6"></a-entity>
    <a-entity light="type: directional; color: #fff; intensity: 0.7" position="0 4 -2"></a-entity>

    <!-- Ground -->
    <a-plane id="ground" rotation="-90 0 0" width="30" height="30" color="#5bb66d" material="roughness:1; metalness:0"></a-plane>

    <!-- Ball (on the ground, grabbable) -->
    <a-sphere id="ball"
              class="grabbable"
              position="0 0.25 -1.8"
              radius="0.25"
              color="#ff8800"
              material="metalness:0.2; roughness:0.5; color:#ff8800"
              simple-physics="radius:0.25; groundY:0">
    </a-sphere>

    <!-- Camera (desktop WASD + mouse look) -->
    <a-entity id="rig" position="0 1.6 1">
      <a-entity camera look-controls wasd-controls></a-entity>
    </a-entity>

    <!-- Desktop mouse ray + grabber -->
    <a-entity id="mouseCursor"
              cursor="rayOrigin: mouse"
              raycaster="objects: .grabbable; far: 10"
              pickup-controller="mode: mouse">
    </a-entity>

    <!-- VR controllers with visible rays -->
    <a-entity id="leftHand"
              laser-controls="hand: left"
              raycaster="objects: .grabbable; far: 3"
              pickup-controller="mode: xr">
    </a-entity>
    <a-entity id="rightHand"
              laser-controls="hand: right"
              raycaster="objects: .grabbable; far: 3"
              pickup-controller="mode: xr">
    </a-entity>

    <!-- Sky -->
    <a-sky color="#cbe9ff"></a-sky>

    <!-- Scripts: grabbing + very simple gravity/ground bounce -->
    <script>
      AFRAME.registerComponent('simple-physics', {
        schema: { radius: {default: 0.25}, groundY: {default: 0} },
        init: function () {
          this.vel = new THREE.Vector3(0, 0, 0);
          this.tmp = new THREE.Vector3();
        },
        tick: function (time, dt) {
          if (dt === 0) return;
          const el = this.el;
          // Skip physics while grabbed
          if (el.is && el.is('grabbed')) { this.vel.set(0,0,0); return; }

          dt = dt / 1000;
          // Gravity
          this.vel.y += -9.8 * dt;
          // Integrate
          const p = el.object3D.position;
          p.x += this.vel.x * dt;
          p.y += this.vel.y * dt;
          p.z += this.vel.z * dt;

          // Ground collision (simple)
          const minY = this.data.groundY + this.data.radius;
          if (p.y < minY) {
            p.y = minY;
            if (this.vel.y < 0) this.vel.y *= -0.3; // bounce with damping
            // simple friction
            this.vel.x *= 0.85;
            this.vel.z *= 0.85;
            if (Math.abs(this.vel.y) < 0.2) this.vel.y = 0;
            if (Math.abs(this.vel.x) < 0.02) this.vel.x = 0;
            if (Math.abs(this.vel.z) < 0.02) this.vel.z = 0;
          }
        }
      });

      // Utility: (safe) reparent while preserving world transform.
      function attachPreserveWorld(childEl, newParentEl) {
        const child = childEl.object3D;
        const newParent = newParentEl.object3D;
        if (typeof newParent.attach === 'function') { // modern three.js
          newParent.attach(child);
          return;
        }
        // Fallback
        const worldPos = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        const worldScale = new THREE.Vector3();
        child.getWorldPosition(worldPos);
        child.getWorldQuaternion(worldQuat);
        child.getWorldScale(worldScale);
        newParent.add(child);
        child.position.copy(newParent.worldToLocal(worldPos));
        child.quaternion.copy(worldQuat);
        child.scale.copy(worldScale);
      }

      AFRAME.registerComponent('pickup-controller', {
        schema: { mode: {default: 'xr'} }, // 'xr' for VR controllers, 'mouse' for desktop mouse
        init: function () {
          this.grabbedEl = null;
          this.originalParent = null;

          // Bind handlers
          this.onSelectStart = this.onSelectStart.bind(this);
          this.onSelectEnd = this.onSelectEnd.bind(this);

          if (this.data.mode === 'xr') {
            this.el.addEventListener('selectstart', this.onSelectStart);
            this.el.addEventListener('selectend', this.onSelectEnd);
          } else { // mouse
            // Use mousedown/up anywhere; ray comes from this entity's raycaster (rayOrigin: mouse)
            window.addEventListener('mousedown', this.onSelectStart);
            window.addEventListener('mouseup', this.onSelectEnd);
          }
        },
        remove: function () {
          if (this.data.mode === 'xr') {
            this.el.removeEventListener('selectstart', this.onSelectStart);
            this.el.removeEventListener('selectend', this.onSelectEnd);
          } else {
            window.removeEventListener('mousedown', this.onSelectStart);
            window.removeEventListener('mouseup', this.onSelectEnd);
          }
        },
        getFirstHit: function () {
          const rc = this.el.components.raycaster;
          if (!rc) return null;
          const hits = rc.intersections || [];
          for (let i = 0; i < hits.length; i++) {
            const target = hits[i].object && hits[i].object.el;
            if (target && target.classList && target.classList.contains('grabbable')) {
              return target;
            }
          }
          return null;
        },
        onSelectStart: function () {
          if (this.grabbedEl) return;
          const hitEl = this.getFirstHit();
          if (!hitEl) return;

          this.grabbedEl = hitEl;
          this.originalParent = hitEl.object3D.parent.el || hitEl.sceneEl;

          // Mark grabbed (disables simple-physics)
          this.grabbedEl.addState && this.grabbedEl.addState('grabbed');

          // Parent to controller/mouse ray entity
          attachPreserveWorld(this.grabbedEl, this.el);

          // Bring slightly in front of the controller/ray for a nicer hold position
          const obj = this.grabbedEl.object3D;
          obj.position.z = Math.min(obj.position.z, -0.15);

          // Zero velocity so it doesn't "leak" when released
          const phys = this.grabbedEl.components['simple-physics'];
          if (phys) phys.vel.set(0,0,0);
        },
        onSelectEnd: function () {
          if (!this.grabbedEl) return;

          // Return to original parent (usually scene)
          attachPreserveWorld(this.grabbedEl, this.originalParent);

          // Unmark grabbed (re-enables simple-physics)
          this.grabbedEl.removeState && this.grabbedEl.removeState('grabbed');

          // tiny drop impulse feels nicer
          const phys = this.grabbedEl.components['simple-physics'];
          if (phys) {
            phys.vel.set(0, -0.1, 0);
          }

          this.grabbedEl = null;
          this.originalParent = null;
        }
      });
    </script>
  </a-scene>
</body>
</html>
