<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Infinite Rainbow Labyrinth (Web)</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; color: #fff; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #canvas { display: block; margin: 0 auto; image-rendering: pixelated; }
    #hud { position: fixed; left: 12px; top: 10px; font-size: 14px; opacity: 0.9; user-select: none; }
    #help { position: fixed; left: 12px; top: 30px; font-size: 12px; color: #bfbfbf; opacity: 0.9; user-select: none; }
    #shootBtn, #dpad { position: fixed; touch-action: none; }
    #shootBtn { right: 20px; bottom: 20px; width: 80px; height: 80px; background: rgba(255,255,255,0); }
    #dpad { left: 20px; bottom: 20px; width: 120px; height: 120px; }
    #dpad .pad { position: absolute; width: 40px; height: 40px; background: rgba(255,255,255,0); }
    #dpad .up { left: 40px; top: 0; }
    #dpad .down { left: 40px; bottom: 0; }
    #dpad .left { left: 0; top: 40px; }
    #dpad .right { right: 0; top: 40px; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <canvas id="canvas" width="960" height="600"></canvas>
  <div id="hud"></div>
  <div id="help">Move: W/S, Look: A/D or ←/→, Reset: R</div>
  <div id="dpad" class="hidden">
    <div class="pad up" data-code="KeyW"></div>
    <div class="pad down" data-code="KeyS"></div>
    <div class="pad left" data-code="KeyA"></div>
    <div class="pad right" data-code="KeyD"></div>
  </div>
  <div id="shootBtn" class="hidden"></div>
  <script>
  // ------------------------------------------------------------
  // Infinite (no-global-memory) Zelda-style labyrinth raycaster (Web)
  // ------------------------------------------------------------

  // ---------------- Canvas & timing ----------------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  let W = canvas.width;
  let H = canvas.height;
  let HALF_H = (H / 2) | 0;

  ctx.imageSmoothingEnabled = false;

  // --- Blaster overlay (HUD) ---
  const blasterImg = new Image();
  blasterImg.src = 'blaster.png';

  let BLASTER_SCALE = 5.0;

  const SWAY_DUR   = 0.35;
  const SWAY_AMP_X = 18;
  const SWAY_AMP_Y = 12;

  const BLASTER_BLEED_X = SWAY_AMP_X + 6;
  const BLASTER_BLEED_Y = 6;

  let swayClock = 0;
  let lastYawSign = 0;
  let lastBlasterRect = null;

  function drawBlaster(turning, moving, yawSign, clock) {
    if (!blasterImg.complete) return;
    const u = ((clock % SWAY_DUR) / SWAY_DUR);
    const parab = (turning || moving) ? (4 * u * (1 - u)) : 0;

    const dx = -yawSign * SWAY_AMP_X * parab;
    const dy = (turning || moving ? 1 : 0) * SWAY_AMP_Y * parab;

    const w = blasterImg.width  * BLASTER_SCALE;
    const h = blasterImg.height * BLASTER_SCALE;

    const baseX = W - w + BLASTER_BLEED_X;
    const baseY = H - h + BLASTER_BLEED_Y;

    const x = baseX + dx;
    const y = baseY + dy;

    lastBlasterRect = { x, y, w, h };
    ctx.drawImage(blasterImg, x, y, w, h);
  }

  // --------------- 3D projectiles (sprite-based) ---------------
  const shotImg = new Image();
  shotImg.src = 'blast.png';

  const shots = [];
  const SHOT_SPEED = 18.0;      // tiles / second
  const SHOT_TTL   = 1.2;       // seconds max lifetime
  const SHOT_SCALE = 0.5;       // ✱ CHANGED: 50% size

  function spawnShot() {
    // muzzle offset: a bit forward, a bit to the right of camera
    const forward = 0.80;
    const rightOff = 0.30;

    // ✱ CHANGED: ensure "right" is truly to the player's right on screen
    const rx = -dirY, ry = dirX;

    const sx = posX + dirX * forward + rx * rightOff;
    const sy = posY + dirY * forward + ry * rightOff;

    shots.push({
      x: sx, y: sy,
      vx: dirX * SHOT_SPEED,
      vy: dirY * SHOT_SPEED,
      t: 0
    });
  }

  window.addEventListener('mousedown', (e) => {
    if (e.button === 0) spawnShot();
  });

  function moveShots(dt) {
    for (let i = shots.length - 1; i >= 0; i--) {
      const s = shots[i];
      let remain = dt;
      const STEP = 0.025;

      while (remain > 0) {
        const d = Math.min(STEP, remain);
        const nx = s.x + s.vx * d;
        const ny = s.y + s.vy * d;

        if (!can_move(nx, ny)) { shots.splice(i, 1); break; }

        s.x = nx; s.y = ny; s.t += d; remain -= d;
        if (s.t > SHOT_TTL) { shots.splice(i, 1); break; }
      }
    }
  }

  let zBuf = null;

  function drawShots(zBuf) {
    if (!shotImg.complete) return;

    const order = shots
      .map((s, i) => ({ i, d: (s.x - posX) ** 2 + (s.y - posY) ** 2 }))
      .sort((a, b) => b.d - a.d);

    for (const o of order) {
      const s = shots[o.i];

      const relX = s.x - posX;
      const relY = s.y - posY;
      const invDet = 1.0 / (planeX * dirY - dirX * planeY);
      const transX = invDet * ( dirY * relX - dirX * relY);
      const transY = invDet * (-planeY * relX + planeX * relY);
      if (transY <= 0.0001) continue;

      // ✱ CHANGED: scale down sprite
      const screenX = (W / 2) * (1 + transX / transY);
      const spriteH = Math.abs((H / transY) * SHOT_SCALE);
      const spriteW = spriteH;

      const drawStartY = Math.max(0, ((-spriteH / 2 + HALF_H) | 0));
      const drawEndY   = Math.min(H - 1, ((spriteH / 2 + HALF_H) | 0));
      const drawStartX = Math.max(0, ((-spriteW / 2 + screenX) | 0));
      const drawEndX   = Math.min(W - 1, ((spriteW / 2 + screenX) | 0));

      for (let stripe = drawStartX; stripe <= drawEndX; stripe++) {
        if (transY < zBuf[stripe]) {
          const u = (stripe - (-spriteW / 2 + screenX)) / spriteW;
          const texX = Math.max(0, Math.min(shotImg.width - 1, Math.floor(u * shotImg.width)));
          ctx.drawImage(
            shotImg,
            texX, 0, 1, shotImg.height,
            stripe, drawStartY, 1, drawEndY - drawStartY + 1
          );
        }
      }
    }
  }

  // ✱ CHANGED: scale canvas to the largest possible size inside the window
  // while preserving the 960×600 internal resolution & aspect ratio.
  function resizeToWindow() {
    const targetW = canvas.width;
    const targetH = canvas.height;
    const scale = Math.min(window.innerWidth / targetW, window.innerHeight / targetH);
    canvas.style.width  = Math.round(targetW * scale) + 'px';
    canvas.style.height = Math.round(targetH * scale) + 'px';
  }
  window.addEventListener('resize', resizeToWindow);
  resizeToWindow();

  // Colors
  const SKY = [0,0,0];
  const FLOOR = [0,0,0];

  // ---------------- Raycaster world ----------------
  let WORLD = [];
  let WORLD_W = 0;
  let WORLD_H = 0;

  const WALL_COLOR = new Map(); // id -> [r,g,b]
  const BOUNDARY_ID = 7;
  WALL_COLOR.set(BOUNDARY_ID, [0,0,0]);

  // Camera
  let posX = 8.0, posY = 8.0;
  let dirX = 1.0, dirY = 0.0;
  let planeX = 0.0, planeY = 0.66;
  const MOVE_SPEED = 3.2;
  const ROT_SPEED = 1.0;

  // Tile/grid settings
  const TILE = 18;
  const DOOR_W = 4;
  const PATH_W = 3;
  const BORDER = 2;
  const GRID_SIDE = 3; // 3x3 grid: center + neighbors
  WORLD_W = BORDER * 2 + TILE * GRID_SIDE;
  WORLD_H = WORLD_W; // square

  // Directions: 0=N,1=E,2=S,3=W
  const DX = [0, 1, 0, -1];
  const DY = [-1, 0, 1, 0];
  const DIR_NAME = ['N','E','S','W'];
  const left_of = d => (d + 3) % 4;
  const right_of = d => (d + 1) % 4;
  const opposite = d => (d + 2) % 4;

  class Tile {
    constructor(orient_dir, kind, open_sides, wall_id, color, label) {
      this.orient_dir = orient_dir;
      this.kind = kind;
      this.open_sides = new Set(open_sides);
      this.wall_id = wall_id;
      this.color = color;
      this.label = label;
      this.neighbors = new Map();
    }
  }

  let current_tile = null;
  let prev_tile = null;
  const tile_positions = new Map();
  let wall_id_counter = 10;

  function hsvToRgb(h, s, v) {
    let r=0, g=0, b=0;
    let i = Math.floor(h * 6);
    let f = h * 6 - i;
    let p = v * (1 - s);
    let q = v * (1 - f * s);
    let t = v * (1 - (1 - f) * s);
    switch (i % 6) {
      case 0: r=v; g=t; b=p; break;
      case 1: r=q; g=v; b=p; break;
      case 2: r=p; g=v; b=t; break;
      case 3: r=p; g=q; b=v; break;
      case 4: r=t; g=p; b=v; break;
      case 5: r=v; g=p; b=q; break;
    }
    return [ (r*255)|0, (g*255)|0, (b*255)|0 ];
  }

  function rand_rainbow() {
    const h = Math.random();
    const s = 0.9;
    const v = 1.0;
    return hsvToRgb(h, s, v);
  }

  function next_wall_id_with_color() {
    const wid = wall_id_counter++;
    const color = rand_rainbow();
    WALL_COLOR.set(wid, color);
    return [wid, color];
  }

  function generate_tile(orient_dir) {
    const kinds = ['room3', 'dead', 'straight', 'Lleft', 'Lright'];
    const weights = [0.30, 0.12, 0.28, 0.15, 0.15];
    let r = Math.random();
    let acc = 0;
    let kind = kinds[0];
    for (let i=0;i<kinds.length;i++) { acc += weights[i]; if (r <= acc) { kind = kinds[i]; break; } }

    const forward = opposite(orient_dir);
    const L = left_of(orient_dir);
    const R = right_of(orient_dir);

    let open_sides, exits_label;
    if (kind === 'room3') { open_sides = new Set([orient_dir, forward, L, R]); exits_label = '3 exits'; }
    else if (kind === 'dead') { open_sides = new Set([orient_dir]); exits_label = 'dead end'; }
    else if (kind === 'straight') { open_sides = new Set([orient_dir, forward]); exits_label = 'straight'; }
    else if (kind === 'Lleft') { open_sides = new Set([orient_dir, L]); exits_label = 'L-left'; }
    else if (kind === 'Lright') { open_sides = new Set([orient_dir, R]); exits_label = 'L-right'; }
    else { open_sides = new Set([orient_dir]); exits_label = '?'; }

    const [wid, color] = next_wall_id_with_color();
    const label = `${kind} (${exits_label})`;
    return new Tile(orient_dir, kind, open_sides, wid, color, label);
  }

  function empty_world() {
    WORLD_W = BORDER * 2 + TILE * GRID_SIDE;
    WORLD_H = WORLD_W;
    WORLD = new Array(WORLD_H);
    for (let y=0; y<WORLD_H; y++) {
      WORLD[y] = new Array(WORLD_W).fill(0);
    }
    for (let x=0; x<WORLD_W; x++) {
      WORLD[0][x] = BOUNDARY_ID;
      WORLD[WORLD_H-1][x] = BOUNDARY_ID;
    }
    for (let y=0; y<WORLD_H; y++) {
      WORLD[y][0] = BOUNDARY_ID;
      WORLD[y][WORLD_W-1] = BOUNDARY_ID;
    }
  }

  function carve_door(edge, ox, oy) {
    const cx = (ox + (TILE/2)|0);
    const cy = (oy + (TILE/2)|0);
    const half = (DOOR_W/2)|0;
    if (edge === 0) { const y = oy; for (let i=-half; i<=half; i++) WORLD[y][cx + i] = 0; }
    else if (edge === 2) { const y = oy + TILE - 1; for (let i=-half; i<=half; i++) WORLD[y][cx + i] = 0; }
    else if (edge === 1) { const x = ox + TILE - 1; for (let i=-half; i<=half; i++) WORLD[cy + i][x] = 0; }
    else if (edge === 3) { const x = ox; for (let i=-half; i<=half; i++) WORLD[cy + i][x] = 0; }
  }

  function draw_border_box(ox, oy, wid) {
    for (let x=ox; x<ox+TILE; x++) {
      WORLD[oy][x] = wid;
      WORLD[oy + TILE - 1][x] = wid;
    }
    for (let y=oy; y<oy+TILE; y++) {
      WORLD[y][ox] = wid;
      WORLD[y][ox + TILE - 1] = wid;
    }
  }

  function fill_interior(ox, oy, wid) {
    for (let y=oy+1; y<oy+TILE-1; y++) {
      for (let x=ox+1; x<ox+TILE-1; x++) {
        WORLD[y][x] = wid;
      }
    }
  }

  function carve_rect(x0, y0, x1, y1) {
    if (x0 > x1) { let t=x0; x0=x1; x1=t; }
    if (y0 > y1) { let t=y0; y0=y1; y1=t; }
    x0 = Math.max(1, x0); y0 = Math.max(1, y0);
    x1 = Math.min(WORLD_W-2, x1); y1 = Math.min(WORLD_H-2, y1);
    for (let y=y0; y<=y1; y++) {
      for (let x=x0; x<=x1; x++) {
        WORLD[y][x] = 0;
      }
    }
  }

  function build_room(ox, oy, tile) {
    draw_border_box(ox, oy, tile.wall_id);
    for (const side of tile.open_sides) carve_door(side, ox, oy);
  }

  function build_hall_straight(ox, oy, tile) {
    draw_border_box(ox, oy, tile.wall_id);
    fill_interior(ox, oy, tile.wall_id);
    const cx = (ox + (TILE/2)|0);
    const cy = (oy + (TILE/2)|0);
    if (tile.orient_dir === 0 || tile.orient_dir === 2) {
      carve_rect(cx - (PATH_W>>1), oy+1, cx + (PATH_W>>1), oy + TILE - 2);
    } else {
      carve_rect(ox+1, cy - (PATH_W>>1), ox + TILE - 2, cy + (PATH_W>>1));
    }
    for (const side of tile.open_sides) carve_door(side, ox, oy);
  }

  function build_hall_L(ox, oy, tile, turn_to) {
    draw_border_box(ox, oy, tile.wall_id);
    fill_interior(ox, oy, tile.wall_id);
    const cx = (ox + (TILE/2)|0);
    const cy = (oy + (TILE/2)|0);
    if (tile.orient_dir === 0 || tile.orient_dir === 2) {
      carve_rect(cx - (PATH_W>>1), oy+1, cx + (PATH_W>>1), cy);
    } else {
      carve_rect(ox+1, cy - (PATH_W>>1), cx, cy + (PATH_W>>1));
    }
    if (turn_to === 0 || turn_to === 2) {
      carve_rect(cx - (PATH_W>>1), cy, cx + (PATH_W>>1), oy + TILE - 2);
    } else {
      carve_rect(cx, cy - (PATH_W>>1), ox + TILE - 2, cy + (PATH_W>>1));
    }
    for (const side of tile.open_sides) carve_door(side, ox, oy);
  }

  function build_tile_at(ox, oy, tile) {
    if (tile.kind === 'room3' || tile.kind === 'dead') {
      build_room(ox, oy, tile);
    } else if (tile.kind === 'straight') {
      build_hall_straight(ox, oy, tile);
    } else if (tile.kind === 'Lleft') {
      build_hall_L(ox, oy, tile, left_of(tile.orient_dir));
    } else if (tile.kind === 'Lright') {
      build_hall_L(ox, oy, tile, right_of(tile.orient_dir));
    } else {
      build_room(ox, oy, tile);
    }
  }

  function grid_origin(tx, ty) {
    const ox = BORDER + tx * TILE;
    const oy = BORDER + ty * TILE;
    return [ox, oy];
  }

  function rebuild_world(center, prev, back_side) {
    empty_world();
    tile_positions.clear();

    const [cx, cy] = grid_origin(1,1);
    build_tile_at(cx, cy, center);
    tile_positions.set(center, [cx, cy]);

    if (prev && back_side !== null && back_side !== undefined) {
      const tx = 1 + DX[back_side];
      const ty = 1 + DY[back_side];
      if (0 <= tx && tx < GRID_SIDE && 0 <= ty && ty < GRID_SIDE) {
        const [ox, oy] = grid_origin(tx, ty);
        build_tile_at(ox, oy, prev);
        tile_positions.set(prev, [ox, oy]);
      }
    }

    for (const [side, neigh] of center.neighbors.entries()) {
      const tx = 1 + DX[side];
      const ty = 1 + DY[side];
      if (0 <= tx && tx < GRID_SIDE && 0 <= ty && ty < GRID_SIDE) {
        const [ox, oy] = grid_origin(tx, ty);
        build_tile_at(ox, oy, neigh);
        tile_positions.set(neigh, [ox, oy]);
      }
    }
  }

  function generate_neighbors_for_center(center, back_side) {
    center.neighbors.clear();
    for (const side of center.open_sides) {
      if (back_side !== null && back_side !== undefined && side === back_side) continue;
      const neigh = generate_tile(opposite(side));
      center.neighbors.set(side, neigh);
    }
  }

  function back_side_of_current() {
    if (!prev_tile) return null;
    const c = tile_positions.get(current_tile);
    const p = tile_positions.get(prev_tile);
    if (!c || !p) return null;
    const [cox, coy] = c;
    const [pox, poy] = p;
    const dx = ((pox - cox) / TILE) | 0;
    const dy = ((poy - coy) / TILE) | 0;
    if (dx === 0 && dy === -1) return 0;
    if (dx === 1 && dy === 0) return 1;
    if (dx === 0 && dy === 1) return 2;
    if (dx === -1 && dy === 0) return 3;
    return null;
  }

  function can_move(nx, ny) {
    const xi = nx | 0;
    const yi = ny | 0;
    if (yi < 0 || yi >= WORLD_H || xi < 0 || xi >= WORLD_W) return false;
    return WORLD[yi][xi] === 0;
  }

  function which_tile_contains(x, y) {
    for (const [t, origin] of tile_positions.entries()) {
      const [ox, oy] = origin;
      if (ox < x && x < ox + TILE - 1 && oy < y && y < oy + TILE - 1) {
        if (t === current_tile) return [t, null];
        const [cox, coy] = tile_positions.get(current_tile);
        const dx = ((ox - cox) / TILE) | 0;
        const dy = ((oy - coy) / TILE) | 0;
        let d = null;
        if (dx === 0 && dy === -1) d = 0;
        else if (dx === 1 && dy === 0) d = 1;
        else if (dx === 0 && dy === 1) d = 2;
        else if (dx === -1 && dy === 0) d = 3;
        return [t, d];
      }
    }
    return [null, null];
  }

  function enter_neighbor(direction) {
    const back_dir = back_side_of_current();
    let next_tile;
    if (direction === back_dir && prev_tile) {
      next_tile = prev_tile;
    } else {
      next_tile = current_tile.neighbors.get(direction);
      if (!next_tile) return;
    }
    const old_pos = tile_positions.get(next_tile);
    const [old_ox, old_oy] = old_pos;

    const old_center = current_tile;
    prev_tile = old_center;

    const arrived_from = opposite(direction);
    generate_neighbors_for_center(next_tile, arrived_from);
    rebuild_world(next_tile, prev_tile, arrived_from);

    const [new_ox, new_oy] = tile_positions.get(next_tile);
    posX = posX - old_ox + new_ox;
    posY = posY - old_oy + new_oy;
    for (const s of shots) {
      s.x = s.x - old_ox + new_ox;
      s.y = s.y - old_oy + new_oy;
    }

    current_tile = next_tile;
  }

  function ensure_neighbors_visible() {
    const [t, d] = which_tile_contains(posX, posY);
    if (t && t !== current_tile && d !== null) enter_neighbor(d);
  }

  function start_new_run() {
    current_tile = generate_tile(3);
    current_tile.kind = 'room3';
    current_tile.open_sides = new Set([0,1,2,3]);
    generate_neighbors_for_center(current_tile, 3);

    prev_tile = null;
    rebuild_world(current_tile, prev_tile, null);

    const [ox, oy] = tile_positions.get(current_tile);
    posX = ox + TILE * 0.5;
    posY = oy + TILE * 0.5;
    dirX = 1.0; dirY = 0.0;
    planeX = 0.0; planeY = 0.66;
  }

  // ---------------- Input ----------------
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    keys.add(e.code);
    if (e.code === 'KeyR') start_new_run();
  });
  window.addEventListener('keyup', (e) => keys.delete(e.code));
  const isMobile = /Mobi|Android|iPhone|iPad|iPod|Touch/i.test(navigator.userAgent);
  if (isMobile) {
    const dpad = document.getElementById('dpad');
    const shootBtn = document.getElementById('shootBtn');
    dpad.classList.remove('hidden');
    shootBtn.classList.remove('hidden');
    const mapTouch = (el, code) => {
      el.addEventListener('touchstart', e => { e.preventDefault(); keys.add(code); });
      const up = e => { e.preventDefault(); keys.delete(code); };
      el.addEventListener('touchend', up);
      el.addEventListener('touchcancel', up);
    };
    mapTouch(dpad.querySelector('.up'), 'KeyW');
    mapTouch(dpad.querySelector('.down'), 'KeyS');
    mapTouch(dpad.querySelector('.left'), 'KeyA');
    mapTouch(dpad.querySelector('.right'), 'KeyD');
    shootBtn.addEventListener('touchstart', e => { e.preventDefault(); spawnShot(); });
  }

  // ---------------- Rendering ----------------
  function fillRectColor(x, y, w, h, rgb) {
    ctx.fillStyle = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
    ctx.fillRect(x, y, w, h);
  }

  function loop() {
    const now = performance.now();
    const dt = Math.min(0.05, (now - loop.lastNow) / 1000 || 0.016);
    loop.lastNow = now;

    // Rotation
    let rot = 0.0;
    if (keys.has('KeyD') || keys.has('ArrowRight')) rot += ROT_SPEED * dt * 3;
    if (keys.has('KeyA') || keys.has('ArrowLeft'))  rot -= ROT_SPEED * dt * 3;
    if (rot !== 0.0) {
      const cos = Math.cos(rot), sin = Math.sin(rot);
      const oldDirX = dirX;
      dirX = dirX * cos - dirY * sin;
      dirY = oldDirX * sin + dirY * cos;
      const oldPlaneX = planeX;
      planeX = planeX * cos - planeY * sin;
      planeY = oldPlaneX * sin + planeY * cos;
    }

    // Movement
    const move = MOVE_SPEED * dt * 3;
    if (keys.has('KeyW')) {
      const nx = posX + dirX * move, ny = posY + dirY * move;
      if (can_move(nx, posY)) posX = nx;
      if (can_move(posX, ny)) posY = ny;
    }
    if (keys.has('KeyS')) {
      const nx = posX - dirX * move, ny = posY - dirY * move;
      if (can_move(nx, posY)) posX = nx;
      if (can_move(posX, ny)) posY = ny;
    }

    ensure_neighbors_visible();

    moveShots(dt);

    fillRectColor(0, 0, W, HALF_H, SKY);
    fillRectColor(0, HALF_H, W, HALF_H, FLOOR);

    for (let x=0; x<W; x++) {
      const cameraX = 2 * x / W - 1;
      const rayDirX = dirX + planeX * cameraX;
      const rayDirY = dirY + planeY * cameraX;

      let mapX = posX | 0;
      let mapY = posY | 0;

      const INF = 1e30;
      const deltaDistX = rayDirX !== 0 ? Math.abs(1.0 / rayDirX) : INF;
      const deltaDistY = rayDirY !== 0 ? Math.abs(1.0 / rayDirY) : INF;

      let stepX, stepY, sideDistX, sideDistY;
      if (rayDirX < 0) { stepX = -1; sideDistX = (posX - mapX) * deltaDistX; }
      else { stepX = 1; sideDistX = (mapX + 1.0 - posX) * deltaDistX; }
      if (rayDirY < 0) { stepY = -1; sideDistY = (posY - mapY) * deltaDistY; }
      else { stepY = 1; sideDistY = (mapY + 1.0 - posY) * deltaDistY; }

      let hit = false; let side = 0; let tile_id = 0;
      let guard = 0;
      while (!hit && guard++ < 4096) {
        if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
        else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
        if (mapY < 0 || mapY >= WORLD_H || mapX < 0 || mapX >= WORLD_W) { hit = true; tile_id = BOUNDARY_ID; break; }
        tile_id = WORLD[mapY][mapX];
        if (tile_id !== 0) hit = true;
      }

      let perpWallDist;
      if (side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2.0) / (rayDirX || 1e-9);
      else perpWallDist = (mapY - posY + (1 - stepY) / 2.0) / (rayDirY || 1e-9);
      if (!(perpWallDist > 0)) perpWallDist = 1e-6;

      const lineHeight = (H / perpWallDist) | 0;
      const drawStart = Math.max(0, ((-lineHeight / 2 + HALF_H) | 0));
      const drawEnd = Math.min(H - 1, ((lineHeight / 2 + HALF_H) | 0));

      let base = WALL_COLOR.get(tile_id) || [255,255,255];
      if (side === 1) base = [(base[0]*0.75)|0, (base[1]*0.75)|0, (base[2]*0.75)|0];
      const shade = Math.max(0.4, Math.min(1.0, 2.0 / (perpWallDist + 0.5)));
      const color = [(base[0]*shade)|0, (base[1]*shade)|0, (base[2]*shade)|0];

      ctx.fillStyle = `rgb(${color[0]},${color[1]},${color[2]})`;
      ctx.fillRect(x, drawStart, 1, drawEnd - drawStart + 1);

      if (!zBuf) zBuf = new Float32Array(W);
      zBuf[x] = perpWallDist;
    }

    drawShots(zBuf);

    const hud = document.getElementById('hud');
    hud.textContent = `${current_tile?.label || ''}`;

    const turning = (rot !== 0);
    const moving  = keys.has('KeyW') || keys.has('KeyS');

    let yawSign = 0;
    if (turning) yawSign = rot > 0 ? 1 : -1;

    if (turning || moving) {
      swayClock += dt;
      if (yawSign !== 0) lastYawSign = yawSign;
    } else {
      swayClock = 0;
      lastYawSign = 0;
    }

    drawBlaster(turning, moving, lastYawSign, swayClock);

    requestAnimationFrame(loop);

  }
  loop.lastNow = performance.now();

  function init() {
    start_new_run();
    W = canvas.width; H = canvas.height; HALF_H = (H/2)|0;
    zBuf = new Float32Array(W);
    requestAnimationFrame(loop);
  }

  init();
  </script>
</body>
</html>
