<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Attack of The Kruptins</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; color: #fff; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #canvas { display: block; margin: 0 auto; image-rendering: pixelated; }
    #hud { position: fixed; left: 12px; top: 10px; font-size: 14px; opacity: 0.9; user-select: none; }
    #help { position: fixed; left: 12px; top: 30px; font-size: 12px; color: #bfbfbf; opacity: 0.9; user-select: none; }

    /* Kill counter (top-right) */
    #kills {
      position: fixed; right: 12px; top: 10px;
      background: rgba(60,60,60,0.85);
      color: #00ff63; font-weight: 700; font-size: 14px;
      padding: 4px 8px; border-radius: 6px; user-select: none;
    }

    /* --- Mobile touch UI --- */
    #touch-ui { 
        position: fixed; 
        inset: 0; 
        pointer-events: none;
        display: none; /* Hide by default */
    }

    /* Only show touch UI on mobile devices */
    @media (hover: none) and (pointer: coarse) {
        #touch-ui {
            display: block;
        }
    }

    #dpad { position: fixed; left: 3vw; bottom: 4vh; width: 28vw; height: 28vw; max-width: 220px; max-height: 220px; pointer-events: auto; }
    .dpad-btn { position: absolute; width: 34%; height: 34%; background: rgba(128,128,128,0.2); border: 2px solid rgba(200,200,200,0.4); border-radius: 14px; color: #fff; font-size: clamp(16px, 6vw, 26px); display: flex; align-items: center; justify-content: center; user-select: none; -webkit-user-select: none; touch-action: none; }
    .dpad-btn:active { background: rgba(160,160,160,0.28); }
    #btn-up    { left: 33%; top: 3%; }
    #btn-down  { left: 33%; bottom: 3%; }
    #btn-left  { top: 33%; left: 3%; }
    #btn-right { top: 33%; right: 3%; }

    #shoot-btn { position: fixed; right: 3vw; bottom: 6vh; width: 18vw; height: 18vw; max-width: 160px; max-height: 160px; border-radius: 50%; background: rgba(0,255,0,0.2); border: 2px solid rgba(140,255,140,0.35); pointer-events: auto; user-select: none; -webkit-user-select: none; touch-action: none; }
    #shoot-btn:active { background: rgba(0,255,0,0.28); }
    .dpad-btn, #shoot-btn { outline: none; }

    /* --- Digital Joystick --- */
    #joystick {
      position: fixed;
      left: 3vw;
      bottom: 4vh;
      width: 28vw;
      height: 28vw;
      max-width: 220px;
      max-height: 220px;
      touch-action: none;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #joystick .outer {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(128,128,128,0.20);
      border-radius: 50%;
      pointer-events: none;
    }

    #joystick .inner {
      position: absolute;
      width: 38%;
      height: 38%;
      left: 31%;
      top: 31%;
      background: rgba(128,128,128,0.50);
      border-radius: 50%;
      pointer-events: auto;
      touch-action: none;
      transition: left 0.08s, top 0.08s;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="960" height="600"></canvas>
  <div id="hud"></div>
  <div id="help">Move: W/S, Look: A/D or ←/→, Reset: R</div>
  <div id="kills">0</div>

  <script>
  // ------------------------------------------------------------
  // Attack of The Kruptins - procedural raycaster (Web)
  // (formerly "Infinite Rainbow Labyrinth")
  // ------------------------------------------------------------

  // ---------------- Canvas & timing ----------------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  let W = canvas.width;
  let H = canvas.height;
  let HALF_H = (H / 2) | 0;
  ctx.imageSmoothingEnabled = false;

  // --- Mobile detection ---
  const MOBILE =
    /Mobi|Android|iPhone|iPad|iPod|Windows Phone|webOS/i.test(navigator.userAgent) ||
    (navigator.maxTouchPoints && navigator.maxTouchPoints > 1);

  if (MOBILE) {
    const help = document.getElementById('help');
    help.textContent = 'Touch: D-pad to move/turn, green button to shoot. (Desktop: W/S, A/D or ←/→, R to reset)';
  }

  // --- Touch control state ---
  const touchFlags = { fwd:false, back:false, left:false, right:false };

  function createTouchUI() {
    const ui = document.createElement('div');
    ui.id = 'touch-ui';

    // --- Digital Joystick ---
    const joystick = document.createElement('div');
    joystick.id = 'joystick';
    joystick.style.position = 'fixed';
    joystick.style.left = '3vw';
    joystick.style.bottom = '4vh';
    joystick.style.width = '28vw';
    joystick.style.height = '28vw';
    joystick.style.maxWidth = '220px';
    joystick.style.maxHeight = '220px';
    joystick.style.touchAction = 'none';
    joystick.style.pointerEvents = 'auto';
    joystick.style.display = 'flex';
    joystick.style.alignItems = 'center';
    joystick.style.justifyContent = 'center';

    // Outer circle
    const outer = document.createElement('div');
    outer.style.position = 'absolute';
    outer.style.left = '0';
    outer.style.top = '0';
    outer.style.width = '100%';
    outer.style.height = '100%';
    outer.style.background = 'rgba(128,128,128,0.20)';
    outer.style.borderRadius = '50%';
    outer.style.pointerEvents = 'none';

    // Inner (thumb) circle
    const inner = document.createElement('div');
    inner.style.position = 'absolute';
    inner.style.width = '38%';
    inner.style.height = '38%';
    inner.style.left = '31%';
    inner.style.top = '31%';
    inner.style.background = 'rgba(128,128,128,0.50)';
    inner.style.borderRadius = '50%';
    inner.style.pointerEvents = 'auto';
    inner.style.touchAction = 'none';
    inner.style.transition = 'left 0.08s, top 0.08s';

    joystick.appendChild(outer);
    joystick.appendChild(inner);
    ui.appendChild(joystick);

    // --- Joystick logic ---
    let joyActive = false, joyStart = null, joyCenter = null, joyRadius = null;

    function resetJoystick() {
      inner.style.left = '31%';
      inner.style.top = '31%';
      touchFlags.fwd = false;
      touchFlags.back = false;
      touchFlags.left = false;
      touchFlags.right = false;
    }

    function setJoyFlagsFromAngle(angle, mag) {
      // 8-way: Up, Up-Right, Right, Down-Right, Down, Down-Left, Left, Up-Left
      // Threshold: only if mag > 0.22 (22% of radius)
      if (mag < 0.22) {
        touchFlags.fwd = false;
        touchFlags.back = false;
        touchFlags.left = false;
        touchFlags.right = false;
        return;
      }
      // Angle: 0 = up, PI/4 = up-right, PI/2 = right, etc.
      // Map to WASD
      // Up: -22.5° to 22.5° (337.5° to 22.5°)
      // Up-Right: 22.5° to 67.5°
      // Right: 67.5° to 112.5°
      // Down-Right: 112.5° to 157.5°
      // Down: 157.5° to 202.5°
      // Down-Left: 202.5° to 247.5°
      // Left: 247.5° to 292.5°
      // Up-Left: 292.5° to 337.5°
      // angle in radians, 0 = up, increases clockwise
      let deg = angle * 180 / Math.PI;
      if (deg < 0) deg += 360;
      // Reset
      touchFlags.fwd = false;
      touchFlags.back = false;
      touchFlags.left = false;
      touchFlags.right = false;
      if ((deg >= 337.5 || deg < 22.5)) { // Up
        touchFlags.fwd = true;
      } else if (deg >= 22.5 && deg < 67.5) { // Up-Right
        touchFlags.fwd = true; touchFlags.right = true;
      } else if (deg >= 67.5 && deg < 112.5) { // Right
        touchFlags.right = true;
      } else if (deg >= 112.5 && deg < 157.5) { // Down-Right
        touchFlags.back = true; touchFlags.right = true;
      } else if (deg >= 157.5 && deg < 202.5) { // Down
        touchFlags.back = true;
      } else if (deg >= 202.5 && deg < 247.5) { // Down-Left
        touchFlags.back = true; touchFlags.left = true;
      } else if (deg >= 247.5 && deg < 292.5) { // Left
        touchFlags.left = true;
      } else if (deg >= 292.5 && deg < 337.5) { // Up-Left
        touchFlags.fwd = true; touchFlags.left = true;
      }
    }

    function getJoyCenterAndRadius() {
      const rect = joystick.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const r = rect.width / 2;
      return { cx, cy, r, rect };
    }

    function updateJoystick(touch) {
      if (!joyCenter) return;
      const dx = touch.clientX - joyCenter.cx;
      const dy = touch.clientY - joyCenter.cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const maxDist = joyRadius * 0.78; // thumb can move up to 78% of radius
      let ndx = dx, ndy = dy;
      let mag = dist / joyRadius;
      if (dist > maxDist) {
        ndx = dx * maxDist / dist;
        ndy = dy * maxDist / dist;
        mag = maxDist / joyRadius;
      }
      // Move thumb
      const left = 50 + (ndx / joyRadius) * 50 - 19; // 19 = half of 38%
      const top = 50 + (ndy / joyRadius) * 50 - 19;
      inner.style.left = `${left}%`;
      inner.style.top = `${top}%`;
      // Angle: 0 = up
      const angle = Math.atan2(ndx, -ndy);
      setJoyFlagsFromAngle(angle, mag);
    }

    inner.addEventListener('touchstart', (e) => {
      e.preventDefault();
      joyActive = true;
      joyCenter = getJoyCenterAndRadius();
      joyRadius = joyCenter.r;
      updateJoystick(e.touches[0]);
    }, { passive: false });

    joystick.addEventListener('touchstart', (e) => {
      e.preventDefault();
      joyActive = true;
      joyCenter = getJoyCenterAndRadius();
      joyRadius = joyCenter.r;
      updateJoystick(e.touches[0]);
    }, { passive: false });

    joystick.addEventListener('touchmove', (e) => {
      if (!joyActive) return;
      e.preventDefault();
      updateJoystick(e.touches[0]);
    }, { passive: false });

    joystick.addEventListener('touchend', (e) => {
      e.preventDefault();
      joyActive = false;
      resetJoystick();
    }, { passive: false });

    joystick.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      joyActive = false;
      resetJoystick();
    }, { passive: false });

    resetJoystick();

    // --- Shoot button (unchanged) ---
    const shoot = document.createElement('button');
    shoot.id = 'shoot-btn'; shoot.setAttribute('aria-label', 'Shoot');
    shoot.addEventListener('touchstart', (e) => { e.preventDefault(); spawnShot(); }, { passive:false });

    ui.appendChild(shoot);
    document.body.appendChild(ui);
    window.addEventListener('contextmenu', (e) => e.preventDefault());
  }
  if (MOBILE) createTouchUI();

  // --- Blaster overlay (HUD) ---
  const blasterImg = new Image();
  blasterImg.src = 'blaster.png';
  const emptyBlasterImg = new Image();
  emptyBlasterImg.src = 'empty.png';
  let BLASTER_SCALE = 5.0;
  const SWAY_DUR   = 0.35;
  const SWAY_AMP_X = 18;
  const SWAY_AMP_Y = 12;
  const BLASTER_BLEED_X = SWAY_AMP_X + 6;
  const BLASTER_BLEED_Y = 6;
  let swayClock = 0, lastYawSign = 0, lastBlasterRect = null;

  // Blaster cooldown system
  let blasterCooldown = 0.0;
  const BLASTER_COOLDOWN_TIME = 1.0; // 1 second

  function drawBlaster(turning, moving, yawSign, clock) {
    const currentImg = blasterCooldown > 0 ? emptyBlasterImg : blasterImg;
    if (!currentImg.complete) return;
    const u = ((clock % SWAY_DUR) / SWAY_DUR);
    const parab = (turning || moving) ? (4 * u * (1 - u)) : 0;
    const dx = -yawSign * SWAY_AMP_X * parab;
    const dy = (turning || moving ? 1 : 0) * SWAY_AMP_Y * parab;
    const w = currentImg.width  * BLASTER_SCALE;
    const h = currentImg.height * BLASTER_SCALE;
    const baseX = W - w + BLASTER_BLEED_X;
    const baseY = H - h + BLASTER_BLEED_Y;
    const x = baseX + dx, y = baseY + dy;
    lastBlasterRect = { x, y, w, h };
    ctx.drawImage(currentImg, x, y, w, h);
  }

  // --------------- Projectiles (sprite-based) ---------------
  const shotImg = new Image(); shotImg.src = 'blast.png';
  const enemyBlastImg = new Image(); enemyBlastImg.src = 'enemyblast.png';
  const shots = [];
  const enemyShots = []; // New: enemy projectiles
  const SHOT_SPEED = 18.0;
  const ENEMY_SHOT_SPEED = 12.0; // Slightly slower than player shots
  const SHOT_TTL   = 1.2;
  const SHOT_SCALE = 0.5; // half size

  function spawnShot() {
    // Check if blaster is on cooldown
    if (blasterCooldown > 0) return;
    
    const forward = 0.80, rightOff = 0.2;
    const rx = -dirY, ry = dirX; // right vector
    const sx = posX + dirX * forward + rx * rightOff;
    const sy = posY + dirY * forward + ry * rightOff;
    shots.push({ x: sx, y: sy, vx: dirX * SHOT_SPEED, vy: dirY * SHOT_SPEED, t: 0 });
    
    // Start cooldown
    blasterCooldown = BLASTER_COOLDOWN_TIME;
  }
  window.addEventListener('mousedown', (e) => { if (e.button === 0) spawnShot(); });

  function moveShots(dt) {
    // Player shots
    for (let i = shots.length - 1; i >= 0; i--) {
      const s = shots[i];
      let remain = dt;
      const STEP = 0.025;
      while (remain > 0) {
        const d = Math.min(STEP, remain);
        const nx = s.x + s.vx * d, ny = s.y + s.vy * d;
        if (!can_move(nx, ny)) { shots.splice(i, 1); break; }
        s.x = nx; s.y = ny; s.t += d; remain -= d;
        if (s.t > SHOT_TTL) { shots.splice(i, 1); break; }
      }
    }
    
    // Enemy shots
    for (let i = enemyShots.length - 1; i >= 0; i--) {
      const s = enemyShots[i];
      let remain = dt;
      const STEP = 0.025;
      while (remain > 0) {
        const d = Math.min(STEP, remain);
        const nx = s.x + s.vx * d, ny = s.y + s.vy * d;
        if (!can_move(nx, ny)) { enemyShots.splice(i, 1); break; }
        s.x = nx; s.y = ny; s.t += d; remain -= d;
        if (s.t > SHOT_TTL) { enemyShots.splice(i, 1); break; }
        
        // Check collision with player
        const playerDist = Math.hypot(s.x - posX, s.y - posY);
        if (playerDist < PLAYER_RADIUS) {
          triggerGameOver();
          enemyShots.splice(i, 1);
          break;
        }
      }
    }
  }

  // ✱ Preserve internal res but stretch to biggest window area
  function resizeToWindow() {
    const targetW = canvas.width, targetH = canvas.height;
    const scale = Math.min(window.innerWidth / targetW, window.innerHeight / targetH);
    canvas.style.width  = Math.round(targetW * scale) + 'px';
    canvas.style.height = Math.round(targetH * scale) + 'px';
  }
  window.addEventListener('resize', resizeToWindow);
  resizeToWindow();

  // Colors
  const SKY = [0,0,0], FLOOR = [0,0,0];

  // ---------------- Raycaster world ----------------
  let WORLD = [];
  let WORLD_W = 0, WORLD_H = 0;

  const WALL_COLOR = new Map(); // id -> [r,g,b]
  const BOUNDARY_ID = 7;
  WALL_COLOR.set(BOUNDARY_ID, [0,0,0]);

  // Add gray color for blocking walls
  const BLOCK_COLOR_ID = 999;
  WALL_COLOR.set(BLOCK_COLOR_ID, [128, 128, 128]); // Gray color

  // Store blocking wall positions for collision detection
  let blockingWalls = new Map(); // tile -> array of {x, y, side} wall positions

  function createExitBlocks(tile) {
    if (!tile || !isRoom(tile)) return;
    
    const origin = tile_positions.get(tile);
    if (!origin) return;
    
    const [ox, oy] = origin;
    const blocks = [];
    
    // Create blocks outside each exit (slightly beyond the door)
    for (const side of tile.open_sides) {
      const cx = ox + (TILE / 2) | 0;
      const cy = oy + (TILE / 2) | 0;
      const half = (DOOR_W / 2) | 0;
      const BLOCK_OFFSET = 2; // Distance outside the room
      
      let blockPositions = [];
      
      if (side === 0) { // North exit
        const blockY = oy - BLOCK_OFFSET;
        for (let i = -half; i <= half; i++) {
          const blockX = cx + i;
          if (blockX >= 0 && blockX < WORLD_W && blockY >= 0 && blockY < WORLD_H) {
            blockPositions.push({x: blockX, y: blockY, side});
          }
        }
      } else if (side === 2) { // South exit
        const blockY = oy + TILE - 1 + BLOCK_OFFSET;
        for (let i = -half; i <= half; i++) {
          const blockX = cx + i;
          if (blockX >= 0 && blockX < WORLD_W && blockY >= 0 && blockY < WORLD_H) {
            blockPositions.push({x: blockX, y: blockY, side});
          }
        }
      } else if (side === 1) { // East exit
        const blockX = ox + TILE - 1 + BLOCK_OFFSET;
        for (let i = -half; i <= half; i++) {
          const blockY = cy + i;
          if (blockX >= 0 && blockX < WORLD_W && blockY >= 0 && blockY < WORLD_H) {
            blockPositions.push({x: blockX, y: blockY, side});
          }
        }
      } else if (side === 3) { // West exit
        const blockX = ox - BLOCK_OFFSET;
        for (let i = -half; i <= half; i++) {
          const blockY = cy + i;
          if (blockX >= 0 && blockX < WORLD_W && blockY >= 0 && blockY < WORLD_H) {
            blockPositions.push({x: blockX, y: blockY, side});
          }
        }
      }
      
      blocks.push(...blockPositions);
    }
    
    blockingWalls.set(tile, blocks);
    
    // Actually place the blocks in the world
    for (const block of blocks) {
      WORLD[block.y][block.x] = BLOCK_COLOR_ID;
    }
    
    // Mark exits as blocked
    for (const side of tile.open_sides) {
      tile.exitBlocks.set(side, true);
    }
  }

  function removeExitBlocks(tile) {
    if (!tile) return;
    
    const blocks = blockingWalls.get(tile);
    if (!blocks) return;
    
    // Remove blocks from world
    for (const block of blocks) {
      if (block.x >= 0 && block.x < WORLD_W && block.y >= 0 && block.y < WORLD_H) {
        WORLD[block.y][block.x] = 0;
      }
    }
    
    // Clear blocking state
    tile.exitBlocks.clear();
    blockingWalls.delete(tile);
  }

  function checkAndUpdateExitBlocks(tile) {
    if (!tile || !tile.hasActiveEnemies) return;
    
    // Count alive enemies in this tile
    const aliveCount = enemies.filter(e => e.tile === tile && e.state === 'alive').length;
    
    if (aliveCount === 0) {
      // All enemies defeated, remove blocks
      tile.hasActiveEnemies = false;
      removeExitBlocks(tile);
    }
  }

  // Camera
  let posX = 8.0, posY = 8.0;
  let dirX = 1.0, dirY = 0.0;
  let planeX = 0.0, planeY = 0.66;
  const MOVE_SPEED = 3.2, ROT_SPEED = 1.0;

  // Tile/grid settings
  const TILE = 18, DOOR_W = 4, PATH_W = 3, BORDER = 2;
  const GRID_SIDE = 3; // 3x3 grid: center + neighbors
  WORLD_W = BORDER * 2 + TILE * GRID_SIDE;
  WORLD_H = WORLD_W;

  // Directions: 0=N,1=E,2=S,3=W
  const DX = [0, 1, 0, -1], DY = [-1, 0, 1, 0];
  const left_of = d => (d + 3) % 4, right_of = d => (d + 1) % 4, opposite = d => (d + 2) % 4;

  class Tile {
    constructor(orient_dir, kind, open_sides, wall_id, color, label) {
      this.orient_dir = orient_dir;
      this.kind = kind;
      this.open_sides = new Set(open_sides);
      this.wall_id = wall_id;
      this.color = color;
      this.label = label;
      this.neighbors = new Map();
      // Enemy lifecycle for this tile: undefined -> (alive) -> killed/spent
      this.enemyState = undefined; // (legacy single-enemy state, no longer used)
      this.spawned = false;        // new: prevents multiple spawn waves
      this.exitBlocks = new Map(); // side -> true if blocked
      this.hasActiveEnemies = false; // tracks if enemies are active in this tile
    }
  }

  let current_tile = null, prev_tile = null;
  const tile_positions = new Map();
  let wall_id_counter = 10;

  function hsvToRgb(h, s, v) {
    let r=0, g=0, b=0;
    let i = Math.floor(h * 6);
    let f = h * 6 - i;
    let p = v * (1 - s);
    let q = v * (1 - f * s);
    let t = v * (1 - (1 - f) * s);
    switch (i % 6) {
      case 0: r=v; g=t; b=p; break;
      case 1: r=q; g=v; b=p; break;
      case 2: r=p; g=v; b=t; break;
      case 3: r=p; g=q; b=v; break;
      case 4: r=t; g=p; b=v; break;
      case 5: r=v; g=p; b=q; break;
    }
    return [ (r*255)|0, (g*255)|0, (b*255)|0 ];
  }
  const rand_rainbow = () => { const h = Math.random(), s = 0.9, v = 1.0; return hsvToRgb(h,s,v); };

  function next_wall_id_with_color() {
    const wid = wall_id_counter++;
    const color = rand_rainbow();
    WALL_COLOR.set(wid, color);
    return [wid, color];
  }

  function generate_tile(orient_dir) {
    const kinds = ['room3', 'dead', 'straight', 'Lleft', 'Lright'];
    const weights = [0.30, 0.12, 0.28, 0.15, 0.15];
    let r = Math.random(), acc = 0, kind = kinds[0];
    for (let i=0;i<kinds.length;i++) { acc += weights[i]; if (r <= acc) { kind = kinds[i]; break; } }
    const forward = opposite(orient_dir), L = left_of(orient_dir), R = right_of(orient_dir);

    let open_sides, exits_label;
    if (kind === 'room3') { open_sides = new Set([orient_dir, forward, L, R]); exits_label = '3 exits'; }
    else if (kind === 'dead') { open_sides = new Set([orient_dir]); exits_label = 'dead end'; }
    else if (kind === 'straight') { open_sides = new Set([orient_dir, forward]); exits_label = 'straight'; }
    else if (kind === 'Lleft') { open_sides = new Set([orient_dir, L]); exits_label = 'L-left'; }
    else if (kind === 'Lright') { open_sides = new Set([orient_dir, R]); exits_label = 'L-right'; }
    else { open_sides = new Set([orient_dir]); exits_label = '?'; }

    const [wid, color] = next_wall_id_with_color();
    const label = `${kind} (${exits_label})`;
    return new Tile(orient_dir, kind, open_sides, wid, color, label);
  }

  function empty_world() {
    WORLD_W = BORDER * 2 + TILE * GRID_SIDE;
    WORLD_H = WORLD_W;
    WORLD = new Array(WORLD_H);
    for (let y=0; y<WORLD_H; y++) WORLD[y] = new Array(WORLD_W).fill(0);
    for (let x=0; x<WORLD_W; x++) { WORLD[0][x] = BOUNDARY_ID; WORLD[WORLD_H-1][x] = BOUNDARY_ID; }
    for (let y=0; y<WORLD_H; y++) { WORLD[y][0] = BOUNDARY_ID; WORLD[y][WORLD_W-1] = BOUNDARY_ID; }
  }

  function carve_door(edge, ox, oy) {
    const cx = (ox + (TILE/2)|0), cy = (oy + (TILE/2)|0), half = (DOOR_W/2)|0;
    if (edge === 0) { const y = oy; for (let i=-half; i<=half; i++) WORLD[y][cx + i] = 0; }
    else if (edge === 2) { const y = oy + TILE - 1; for (let i=-half; i<=half; i++) WORLD[y][cx + i] = 0; }
    else if (edge === 1) { const x = ox + TILE - 1; for (let i=-half; i<=half; i++) WORLD[cy + i][x] = 0; }
    else if (edge === 3) { const x = ox; for (let i=-half; i<=half; i++) WORLD[cy + i][x] = 0; }
  }

  function draw_border_box(ox, oy, wid) {
    for (let x=ox; x<ox+TILE; x++) { WORLD[oy][x] = wid; WORLD[oy + TILE - 1][x] = wid; }
    for (let y=oy; y<oy+TILE; y++) { WORLD[y][ox] = wid; WORLD[y][ox + TILE - 1] = wid; }
  }

  function fill_interior(ox, oy, wid) {
    for (let y=oy+1; y<oy+TILE-1; y++) for (let x=ox+1; x<ox+TILE-1; x++) WORLD[y][x] = wid;
  }

  function carve_rect(x0, y0, x1, y1) {
    if (x0 > x1) [x0, x1] = [x1, x0];
    if (y0 > y1) [y0, y1] = [y1, y0];
    x0 = Math.max(1, x0); y0 = Math.max(1, y0);
    x1 = Math.min(WORLD_W-2, x1); y1 = Math.min(WORLD_H-2, y1);
    for (let y=y0; y<=y1; y++) for (let x=x0; x<=x1; x++) WORLD[y][x] = 0;
  }

  function build_room(ox, oy, tile) {
    draw_border_box(ox, oy, tile.wall_id);
    for (const side of tile.open_sides) carve_door(side, ox, oy);
  }

  function build_hall_straight(ox, oy, tile) {
    draw_border_box(ox, oy, tile.wall_id);
    fill_interior(ox, oy, tile.wall_id);
    const cx = (ox + (TILE/2)|0), cy = (oy + (TILE/2)|0);
    if (tile.orient_dir === 0 || tile.orient_dir === 2) carve_rect(cx - (PATH_W>>1), oy+1, cx + (PATH_W>>1), oy + TILE - 2);
    else carve_rect(ox+1, cy - (PATH_W>>1), ox + TILE - 2, cy + (PATH_W>>1));
    for (const side of tile.open_sides) carve_door(side, ox, oy);
  }

  function build_hall_L(ox, oy, tile, turn_to) {
    draw_border_box(ox, oy, tile.wall_id);
    fill_interior(ox, oy, tile.wall_id);
    const cx = (ox + (TILE/2)|0), cy = (oy + (TILE/2)|0);
    if (tile.orient_dir === 0 || tile.orient_dir === 2) carve_rect(cx - (PATH_W>>1), oy+1, cx + (PATH_W>>1), cy);
    else carve_rect(ox+1, cy - (PATH_W>>1), cx, cy + (PATH_W>>1));
    if (turn_to === 0 || turn_to === 2) carve_rect(cx - (PATH_W>>1), cy, cx + (PATH_W>>1), oy + TILE - 2);
    else carve_rect(cx, cy - (PATH_W>>1), ox + TILE - 2, cy + (PATH_W>>1));
    for (const side of tile.open_sides) carve_door(side, ox, oy);
  }

  function build_tile_at(ox, oy, tile) {
    if (tile.kind === 'room3' || tile.kind === 'dead') build_room(ox, oy, tile);
    else if (tile.kind === 'straight') build_hall_straight(ox, oy, tile);
    else if (tile.kind === 'Lleft') build_hall_L(ox, oy, tile, left_of(tile.orient_dir));
    else if (tile.kind === 'Lright') build_hall_L(ox, oy, tile, right_of(tile.orient_dir));
    else build_room(ox, oy, tile);
  }

  function grid_origin(tx, ty) { return [BORDER + tx * TILE, BORDER + ty * TILE]; }

  function rebuild_world(center, prev, back_side) {
    empty_world();
    tile_positions.clear();
    blockingWalls.clear(); // Clear blocking walls when rebuilding

    const [cx, cy] = grid_origin(1,1);
    build_tile_at(cx, cy, center);
    tile_positions.set(center, [cx, cy]);

    if (prev && back_side !== null && back_side !== undefined) {
      const tx = 1 + DX[back_side], ty = 1 + DY[back_side];
      if (0 <= tx && tx < GRID_SIDE && 0 <= ty && ty < GRID_SIDE) {
        const [ox, oy] = grid_origin(tx, ty);
        build_tile_at(ox, oy, prev);
        tile_positions.set(prev, [ox, oy]);
      }
    }
    for (const [side, neigh] of center.neighbors.entries()) {
      const tx = 1 + DX[side], ty = 1 + DY[side];
      if (0 <= tx && tx < GRID_SIDE && 0 <= ty && ty < GRID_SIDE) {
        const [ox, oy] = grid_origin(tx, ty);
        build_tile_at(ox, oy, neigh);
        tile_positions.set(neigh, [ox, oy]);
      }
    }
    
    // Recreate exit blocks for tiles with active enemies
    for (const [tile, origin] of tile_positions.entries()) {
      if (tile.hasActiveEnemies) {
        createExitBlocks(tile);
      }
    }
  }

  function generate_neighbors_for_center(center, back_side) {
    center.neighbors.clear();
    for (const side of center.open_sides) {
      if (back_side !== null && back_side !== undefined && side === back_side) continue;
      const neigh = generate_tile(opposite(side));
      center.neighbors.set(side, neigh);
    }
  }

  function back_side_of_current() {
    if (!prev_tile) return null;
    const c = tile_positions.get(current_tile), p = tile_positions.get(prev_tile);
    if (!c || !p) return null;
    const [cox, coy] = c, [pox, poy] = p;
    const dx = ((pox - cox) / TILE) | 0, dy = ((poy - coy) / TILE) | 0;
    if (dx === 0 && dy === -1) return 0;
    if (dx === 1 && dy === 0) return 1;
    if (dx === 0 && dy === 1) return 2;
    if (dx === -1 && dy === 0) return 3;
    return null;
  }

  function can_move(nx, ny) {
    const xi = nx | 0, yi = ny | 0;
    if (yi < 0 || yi >= WORLD_H || xi < 0 || xi >= WORLD_W) return false;
    return WORLD[yi][xi] === 0;
  }

  function which_tile_contains(x, y) {
    for (const [t, origin] of tile_positions.entries()) {
      const [ox, oy] = origin;
      if (ox < x && x < ox + TILE - 1 && oy < y && y < oy + TILE - 1) {
        if (t === current_tile) return [t, null];
        const [cox, coy] = tile_positions.get(current_tile);
        const dx = ((ox - cox) / TILE) | 0, dy = ((oy - coy) / TILE) | 0;
        let d = null;
        if (dx === 0 && dy === -1) d = 0;
        else if (dx === 1 && dy === 0) d = 1;
        else if (dx === 0 && dy === 1) d = 2;
        else if (dx === -1 && dy === 0) d = 3;
        
        // Check if the exit in this direction is blocked
        if (d !== null && current_tile.exitBlocks && current_tile.exitBlocks.has(d)) {
          return [null, null]; // Prevent transition if exit is blocked
        }
        
        return [t, d];
      }
    }
    return [null, null];
  }

  // Re-added neighbor transition logic (was missing -> enter_neighbor not defined error)
  function enter_neighbor(direction) {
    const back_dir = back_side_of_current();
    let next_tile;
    if (direction === back_dir && prev_tile) next_tile = prev_tile;
    else {
      next_tile = current_tile.neighbors.get(direction);
      if (!next_tile) return;
    }

    const old_center = current_tile;

    // Despawn all remaining alive enemies from old center (progression but no kills)
    despawnEnemiesInTile(old_center);

    const oldNextOrigin = tile_positions.get(next_tile);
    const oldNextOx = oldNextOrigin[0];
    const oldNextOy = oldNextOrigin[1];

    prev_tile = old_center;
    const arrived_from = opposite(direction);

    generate_neighbors_for_center(next_tile, arrived_from);
    rebuild_world(next_tile, prev_tile, arrived_from);

    const [newNextOx, newNextOy] = tile_positions.get(next_tile);

    posX = posX - oldNextOx + newNextOx;
    posY = posY - oldNextOy + newNextOy;
    for (const s of shots) {
      s.x = s.x - oldNextOx + newNextOx;
      s.y = s.y - oldNextOy + newNextOy;
    }

    current_tile = next_tile;
    maybeSpawnEnemiesFor(current_tile);
  }

  // ---------- Enemies (multi-enemy overhaul) ----------
  const enemyImg = new Image(); enemyImg.src = 'enemy.png';
  const rangedEnemyImg = new Image(); rangedEnemyImg.src = 'rangedenemy.png';
  const ENEMY_RADIUS = 0.35;
  const PLAYER_RADIUS = 0.35;
  const ENEMY_SCALE = 0.9;

  // Difficulty / progression
  let kills = 0, clears = 0, maxDifficulty = 0.0;
  const killsBox = document.getElementById('kills');
  const updateKillsUI = () => killsBox.textContent = String(kills);

  // Ranged enemy constants
  const RANGED_ENEMY_SPEED = 2.25; // Fixed speed (about green normal enemy)
  const RANGED_FIRE_RATES = {
    blue: 3.0,   // Fire every 3 seconds
    green: 2.0,  // Fire every 2 seconds  
    red: 1.0     // Fire every 1 second
  };
  const TELEGRAPH_DURATION = 0.3; // Flash duration before firing
  const FLASH_INTERVAL = 0.1; // Flash on/off interval

  // Color & speed mapping (d in [0,1]): Blue->Green->Red
  function enemyColorForDifficulty(d) {
    if (d < 0.5) {
      const t = d / 0.5; // 0→1
      return [
        0,
        Math.round(180 + 75 * t), // G: 180→255
        Math.round(255 * (1 - t)) // B: 255→0
      ];
    } else {
      const t = (d - 0.5) / 0.5;
      return [
        Math.round(255 * t),      // R: 0→255
        Math.round(255 * (1 - t)),// G: 255→0
        0
      ];
    }
  }
  function enemySpeedForDifficulty(d) {
    return 1.0 + 2.5 * d; // blue 1.0 → red 3.5
  }

  function getRangedEnemyFireRate(difficulty) {
    if (difficulty < 0.33) return RANGED_FIRE_RATES.blue;
    if (difficulty < 0.66) return RANGED_FIRE_RATES.green;
    return RANGED_FIRE_RATES.red;
  }

  // Tint helper
  // REMOVE old enemyTintCanvas / enemyTintCtx and pixel loop (was causing DOMException)
  // const enemyTintCanvas = document.createElement('canvas');
  // const enemyTintCtx = enemyTintCanvas.getContext('2d');
  function makeTintedEnemyCanvas(color, isRanged = false) {
    const sourceImg = isRanged ? rangedEnemyImg : enemyImg;
    if (!sourceImg.complete || !sourceImg.naturalWidth) return null;
    const [r,g,b] = color;
    const c = document.createElement('canvas');
    c.width = sourceImg.width;
    c.height = sourceImg.height;
    const gctx = c.getContext('2d');

    // 1. Draw original grayscale
    gctx.drawImage(sourceImg, 0, 0);

    // 2. Multiply color to preserve shading
    gctx.globalCompositeOperation = 'multiply';
    gctx.fillStyle = `rgb(${r},${g},${b})`;
    gctx.fillRect(0, 0, c.width, c.height);

    // 3. Re-apply original alpha (mask)
    gctx.globalCompositeOperation = 'destination-in';
    gctx.drawImage(sourceImg, 0, 0);

    // Reset blend mode for later draws
    gctx.globalCompositeOperation = 'source-over';
    return c;
  }

  function makeWhiteFlashCanvas(isRanged = false) {
    const sourceImg = isRanged ? rangedEnemyImg : enemyImg;
    if (!sourceImg.complete || !sourceImg.naturalWidth) return null;
    const c = document.createElement('canvas');
    c.width = sourceImg.width;
    c.height = sourceImg.height;
    const gctx = c.getContext('2d');

    // Draw white version for flash
    gctx.drawImage(sourceImg, 0, 0);
    gctx.globalCompositeOperation = 'source-in';
    gctx.fillStyle = 'white';
    gctx.fillRect(0, 0, c.width, c.height);
    gctx.globalCompositeOperation = 'source-over';
    return c;
  }

  // Replace single spawn helper with multi-point provider
  function getEnemySpawnPoints(tile_origin) {
    const [ox, oy] = tile_origin;
    return [
      [ox + TILE * 0.50, oy + TILE * 0.50], // center
      [ox + TILE * 0.25, oy + TILE * 0.25],
      [ox + TILE * 0.75, oy + TILE * 0.25],
      [ox + TILE * 0.25, oy + TILE * 0.75],
      [ox + TILE * 0.75, oy + TILE * 0.75],
    ];
  }

  let enemies = []; // replaces single 'enemy'

  const isRoom = (tile) => tile && (tile.kind === 'room3' || tile.kind === 'dead' || tile.kind === 'start');

  function maybeSpawnEnemiesFor(tile) {
    if (!isRoom(tile) || tile.isStart || tile.spawned) return;
    tile.spawned = true;

    maxDifficulty = Math.min(1.0, clears / 20.0);

    // Decide how many enemies (1–4)
    const count = 1 + ((Math.random() * 4) | 0);

    // Unique spawn points
    const pts = getEnemySpawnPoints(tile_positions.get(tile));
    // Fisher–Yates shuffle
    for (let i = pts.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [pts[i], pts[j]] = [pts[j], pts[i]];
    }

    // Check if ranged enemies should be introduced (when normal enemies reach red = maxDifficulty >= 1.0)
    const canSpawnRanged = maxDifficulty >= 1.0;

    for (let i = 0; i < count; i++) {
      const [ex, ey] = pts[i];
      
      // Determine enemy type
      let isRanged = false;
      if (canSpawnRanged && Math.random() < 0.4) { // 40% chance for ranged when unlocked
        isRanged = true;
      }
      
      if (isRanged) {
        // Ranged enemy: start from blue difficulty but with own progression
        const rangedProgress = Math.max(0, (maxDifficulty - 1.0) * 3); // Scale after normal enemies max out
        const difficulty = Math.min(1.0, rangedProgress);
        const color = enemyColorForDifficulty(difficulty);
        const fireRate = getRangedEnemyFireRate(difficulty);
        const tint = makeTintedEnemyCanvas(color, true);
        const flashCanvas = makeWhiteFlashCanvas(true);
        
        enemies.push({
          tile,
          x: ex,
          y: ey,
          anim: 0,
          flip: false,
          color,
          speed: RANGED_ENEMY_SPEED,
          difficulty,
          canvas: tint,
          flashCanvas,
          state: 'alive',
          type: 'ranged',
          lastShotTime: 0,
          fireRate,
          telegraphStart: -1, // When telegraph started (-1 = not telegraphing)
          isTelegraphing: false
        });
      } else {
        // Normal enemy
        const difficulty = Math.random() * Math.max(0.05, maxDifficulty);
        const color = enemyColorForDifficulty(difficulty);
        const speed = enemySpeedForDifficulty(difficulty);
        const tint = makeTintedEnemyCanvas(color, false);
        
        enemies.push({
          tile,
          x: ex,
          y: ey,
          anim: 0,
          flip: false,
          color,
          speed,
          difficulty,
          canvas: tint,
          state: 'alive',
          type: 'normal'
        });
      }
    }
    
    // Mark tile as having active enemies and create exit blocks
    tile.hasActiveEnemies = true;
    createExitBlocks(tile);
  }

  function progressAfterStateChange(wasKill) {
    clears++;
    maxDifficulty = Math.min(1.0, clears / 20.0);
    if (wasKill) { kills++; updateKillsUI(); }
  }

  function killEnemy(e) {
    if (e.state !== 'alive') return;
    e.state = 'killed';
    progressAfterStateChange(true);
    
    // Check if all enemies in this tile are defeated
    checkAndUpdateExitBlocks(e.tile);
  }

  function despawnEnemy(e) {
    if (e.state !== 'alive') return;
    e.state = 'spent';
    progressAfterStateChange(false);
    
    // Check if all enemies in this tile are defeated
    checkAndUpdateExitBlocks(e.tile);
  }

  function despawnEnemiesInTile(tile) {
    for (const e of enemies) if (e.tile === tile && e.state === 'alive') despawnEnemy(e);
    // Prune non-alive from active list
    enemies = enemies.filter(e => e.state === 'alive');
    
    // Remove any remaining blocks for this tile
    if (tile) {
      tile.hasActiveEnemies = false;
      removeExitBlocks(tile);
    }
  }

  let gameOverCountdown = -1.0;
  function triggerGameOver() { gameOverCountdown = 1.2; }

  function updateEnemies(dt) {
    if (!enemies.length) return;
    const currentTime = performance.now() / 1000;
    
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      if (e.state !== 'alive') continue;
      
      // Update animation
      e.anim += dt;
      e.flip = Math.sin(e.anim * 8.0) > 0;
      
      if (e.type === 'ranged') {
        // Ranged enemy behavior
        const dx = posX - e.x, dy = posY - e.y;
        const dist = Math.hypot(dx, dy);
        
        // Movement (same as normal enemies but fixed speed)
        if (dist > 1e-4) {
          const step = e.speed * dt;
          const ux = dx / dist, uy = dy / dist;
          const nx = e.x + ux * step, ny = e.y + uy * step;
          if (can_move(nx, e.y)) e.x = nx;
          if (can_move(e.x, ny)) e.y = ny;
        }
        
        // Shooting logic
        if (!e.isTelegraphing && currentTime - e.lastShotTime >= e.fireRate) {
          // Start telegraphing
          e.isTelegraphing = true;
          e.telegraphStart = currentTime;
        }
        
        if (e.isTelegraphing) {
          const telegraphTime = currentTime - e.telegraphStart;
          if (telegraphTime >= TELEGRAPH_DURATION) {
            // Fire projectile
            if (dist > 1e-4) {
              const ux = dx / dist, uy = dy / dist;
              enemyShots.push({
                x: e.x,
                y: e.y,
                vx: ux * ENEMY_SHOT_SPEED,
                vy: uy * ENEMY_SHOT_SPEED,
                t: 0
              });
            }
            e.lastShotTime = currentTime;
            e.isTelegraphing = false;
            e.telegraphStart = -1;
          }
        }
        
        // Collision with player
        if (dist < (PLAYER_RADIUS + ENEMY_RADIUS)) triggerGameOver();
      } else {
        // Normal enemy behavior (unchanged)
        const dx = posX - e.x, dy = posY - e.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 1e-4) {
          const step = e.speed * dt;
          const ux = dx / dist, uy = dy / dist;
          const nx = e.x + ux * step, ny = e.y + uy * step;
          if (can_move(nx, e.y)) e.x = nx;
          if (can_move(e.x, ny)) e.y = ny;
        }

        if (dist < (PLAYER_RADIUS + ENEMY_RADIUS)) triggerGameOver();
      }
    }

    // Shot collisions (player shots vs enemies)
    for (let si = shots.length - 1; si >= 0; si--) {
      const s = shots[si];
      let hit = false;
      for (let ei = enemies.length - 1; ei >= 0; ei--) {
        const e = enemies[ei];
        if (e.state !== 'alive') continue;
        const d2 = (s.x - e.x) ** 2 + (s.y - e.y) ** 2;
        if (d2 < ENEMY_RADIUS * ENEMY_RADIUS) {
          killEnemy(e);
          hit = true;
        }
      }
      if (hit) shots.splice(si, 1);
    }

    // Remove dead/spent enemies from list
    enemies = enemies.filter(e => e.state === 'alive');
  }

  // Replace drawEnemies with depth-sorted rendering
  function drawEnemies(zBuf) {
    // Collect alive, drawable enemies with distance
    const list = [];
    const currentTime = performance.now() / 1000;
    
    for (const e of enemies) {
      if (e.state === 'alive' && e.canvas) {
        const d = (e.x - posX) * (e.x - posX) + (e.y - posY) * (e.y - posY);
        list.push({ e, d });
      }
    }
    // Sort far → near so near overwrites
    list.sort((a,b) => b.d - a.d);

    for (const { e } of list) {
      const relX = e.x - posX;
      const relY = e.y - posY;
      const invDet = 1.0 / (planeX * dirY - dirX * planeY);
      const transX = invDet * ( dirY * relX - dirX * relY);
      const transY = invDet * (-planeY * relX + planeX * relY);
      if (transY <= 0.0001) continue;

      const screenX = (W / 2) * (1 + transX / transY);
      const spriteH = Math.abs((H / transY) * ENEMY_SCALE);
      const aspect = e.canvas.width / e.canvas.height;
      const spriteW = spriteH * aspect;
      const drawStartY = Math.max(0, ((-spriteH / 2 + HALF_H) | 0));
      const drawEndY   = Math.min(H - 1, ((spriteH / 2 + HALF_H) | 0));
      const drawStartX = Math.max(0, ((-spriteW / 2 + screenX) | 0));
      const drawEndX   = Math.min(W - 1, ((spriteW / 2 + screenX) | 0));

      // Determine which canvas to use (normal, flashing, or telegraph)
      let drawCanvas = e.canvas;
      if (e.type === 'ranged' && e.isTelegraphing && e.flashCanvas) {
        const telegraphTime = currentTime - e.telegraphStart;
        // Flash twice during telegraph duration
        const flashCycle = (telegraphTime / FLASH_INTERVAL) % 2;
        if (flashCycle < 1) {
          drawCanvas = e.flashCanvas; // White flash
        }
      }

      for (let stripe = drawStartX; stripe <= drawEndX; stripe++) {
        if (transY < zBuf[stripe]) {
          const u = (stripe - (-spriteW / 2 + screenX)) / spriteW;
          const uu = e.flip ? (1 - u) : u;
          const texX = Math.max(0, Math.min(drawCanvas.width - 1, Math.floor(uu * drawCanvas.width)));
          ctx.drawImage(
            drawCanvas,
            texX, 0, 1, drawCanvas.height,
            stripe, drawStartY, 1, drawEndY - drawStartY + 1
          );
        }
      }
    }
  }

  function drawShots(zBuf) {
    if (!shotImg.complete || !enemyBlastImg.complete) return;
    
    // Draw player shots
    const playerOrder = shots.map((s, i) => ({ i, d: (s.x - posX) ** 2 + (s.y - posY) ** 2, type: 'player' }));
    // Draw enemy shots  
    const enemyOrder = enemyShots.map((s, i) => ({ i, d: (s.x - posX) ** 2 + (s.y - posY) ** 2, type: 'enemy' }));
    
    // Combine and sort by distance
    const allShots = [...playerOrder, ...enemyOrder].sort((a, b) => b.d - a.d);
    
    for (const o of allShots) {
      const shots_array = o.type === 'player' ? shots : enemyShots;
      const shot_img = o.type === 'player' ? shotImg : enemyBlastImg;
      const s = shots_array[o.i];
      
      const relX = s.x - posX, relY = s.y - posY;
      const invDet = 1.0 / (planeX * dirY - dirX * planeY);
      const transX = invDet * ( dirY * relX - dirX * relY);
      const transY = invDet * (-planeY * relX + planeX * relY);
      if (transY <= 0.0001) continue;

      const screenX = (W / 2) * (1 + transX / transY);
      const spriteH = Math.abs((H / transY) * SHOT_SCALE);
      const spriteW = spriteH;

      const drawStartY = Math.max(0, ((-spriteH / 2 + HALF_H) | 0));
      const drawEndY   = Math.min(H - 1, ((spriteH / 2 + HALF_H) | 0));
      const drawStartX = Math.max(0, ((-spriteW / 2 + screenX) | 0));
      const drawEndX   = Math.min(W - 1, ((spriteW / 2 + screenX) | 0));

      for (let stripe = drawStartX; stripe <= drawEndX; stripe++) {
        if (transY < zBuf[stripe]) {
          const u = (stripe - (-spriteW / 2 + screenX)) / spriteW;
          const texX = Math.max(0, Math.min(shot_img.width - 1, Math.floor(u * shot_img.width)));
          ctx.drawImage(shot_img, texX, 0, 1, shot_img.height, stripe, drawStartY, 1, drawEndY - drawStartY + 1);
        }
      }
    }
  }

  // --- Adjust enter_neighbor to despawn remaining enemies in old room ---
  function enter_neighbor(direction) {
    const back_dir = back_side_of_current();
    let next_tile;
    if (direction === back_dir && prev_tile) next_tile = prev_tile;
    else {
      next_tile = current_tile.neighbors.get(direction);
      if (!next_tile) return;
    }

    const old_center = current_tile;

    // Despawn all remaining alive enemies from old center (progression but no kills)
    despawnEnemiesInTile(old_center);

    const oldNextOrigin = tile_positions.get(next_tile);
    const oldNextOx = oldNextOrigin[0];
    const oldNextOy = oldNextOrigin[1];

    prev_tile = old_center;
    const arrived_from = opposite(direction);

    generate_neighbors_for_center(next_tile, arrived_from);
    rebuild_world(next_tile, prev_tile, arrived_from);

    const [newNextOx, newNextOy] = tile_positions.get(next_tile);

    posX = posX - oldNextOx + newNextOx;
    posY = posY - oldNextOy + newNextOy;
    for (const s of shots) {
      s.x = s.x - oldNextOx + newNextOx;
      s.y = s.y - oldNextOy + newNextOy;
    }

    current_tile = next_tile;
    maybeSpawnEnemiesFor(current_tile);
  }

  // ---------------- Input ----------------
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    keys.add(e.code);
    if (e.code === 'KeyR') start_new_run();
  });
  window.addEventListener('keyup', (e) => keys.delete(e.code));

  // ---------------- Rendering ----------------
  function fillRectColor(x, y, w, h, rgb) {
    ctx.fillStyle = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
    ctx.fillRect(x, y, w, h);
  }

  let zBuf = null;

  function loop() {
    const now = performance.now();
    const dt = Math.min(0.05, (now - loop.lastNow) / 1000 || 0.016);
    loop.lastNow = now;

    // Update blaster cooldown
    if (blasterCooldown > 0) {
      blasterCooldown -= dt;
      if (blasterCooldown < 0) blasterCooldown = 0;
    }

    // If game-over, show overlay and countdown to reset
    if (gameOverCountdown >= 0) {
      gameOverCountdown -= dt;
      // draw faint last frame behind overlay by not clearing; then overlay:
      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = '#ff4040';
      ctx.font = 'bold 44px system-ui, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('GAME OVER', W/2, H/2);
      if (gameOverCountdown <= 0) {
        start_new_run();
        gameOverCountdown = -1;
      }
      requestAnimationFrame(loop);
      return;
    }

    // Rotation (keyboard + touch)
    let rot = 0.0;
    const turnRight = keys.has('KeyD') || keys.has('ArrowRight') || (MOBILE && touchFlags.right);
    const turnLeft  = keys.has('KeyA') || keys.has('ArrowLeft')  || (MOBILE && touchFlags.left);
    if (turnRight) rot += ROT_SPEED * dt * 3;
    if (turnLeft)  rot -= ROT_SPEED * dt * 3;
    if (rot !== 0.0) {
      const cos = Math.cos(rot), sin = Math.sin(rot);
      const oldDirX = dirX;
      dirX = dirX * cos - dirY * sin;
      dirY = oldDirX * sin + dirY * cos;
      const oldPlaneX = planeX;
      planeX = planeX * cos - planeY * sin;
      planeY = oldPlaneX * sin + planeY * cos;
    }

    // Movement (keyboard + touch)
    const move = MOVE_SPEED * dt * 3;
    const goFwd  = keys.has('KeyW') || (MOBILE && touchFlags.fwd);
    const goBack = keys.has('KeyS') || (MOBILE && touchFlags.back);
    if (goFwd) {
      const nx = posX + dirX * move, ny = posY + dirY * move;
      if (can_move(nx, posY)) posX = nx;
      if (can_move(posX, ny)) posY = ny;
    }
    if (goBack) {
      const nx = posX - dirX * move, ny = posY - dirY * move;
      if (can_move(nx, posY)) posX = nx;
      if (can_move(posX, ny)) posY = ny;
    }

    ensure_neighbors_visible();
    moveShots(dt);
    updateEnemies(dt); // replaced updateEnemy

    // Sky/floor
    fillRectColor(0, 0, W, HALF_H, SKY);
    fillRectColor(0, HALF_H, W, HALF_H, FLOOR);

    // Walls + zBuffer
    for (let x=0; x<W; x++) {
      const cameraX = 2 * x / W - 1;
      const rayDirX = dirX + planeX * cameraX;
      const rayDirY = dirY + planeY * cameraX;

      let mapX = posX | 0, mapY = posY | 0;
      const INF = 1e30;
      const deltaDistX = rayDirX !== 0 ? Math.abs(1.0 / rayDirX) : INF;
      const deltaDistY = rayDirY !== 0 ? Math.abs(1.0 / rayDirY) : INF;

      let stepX, stepY, sideDistX, sideDistY;
      if (rayDirX < 0) { stepX = -1; sideDistX = (posX - mapX) * deltaDistX; }
      else { stepX = 1; sideDistX = (mapX + 1.0 - posX) * deltaDistX; }
      if (rayDirY < 0) { stepY = -1; sideDistY = (posY - mapY) * deltaDistY; }
      else { stepY = 1; sideDistY = (mapY + 1.0 - posY) * deltaDistY; }

      let hit = false, side = 0, tile_id = 0, guard = 0;
      while (!hit && guard++ < 4096) {
        if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
        else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
        if (mapY < 0 || mapY >= WORLD_H || mapX < 0 || mapX >= WORLD_W) { hit = true; tile_id = BOUNDARY_ID; break; }
        tile_id = WORLD[mapY][mapX];
        if (tile_id !== 0) hit = true;
      }

      let perpWallDist;
      if (side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2.0) / (rayDirX || 1e-9);
      else perpWallDist = (mapY - posY + (1 - stepY) / 2.0) / (rayDirY || 1e-9);
      if (!(perpWallDist > 0)) perpWallDist = 1e-6;

      const lineHeight = (H / perpWallDist) | 0;
      const drawStart = Math.max(0, ((-lineHeight / 2 + HALF_H) | 0));
      const drawEnd = Math.min(H - 1, ((lineHeight / 2 + HALF_H) | 0));

      let base = WALL_COLOR.get(tile_id) || [255,255,255];
      if (side === 1) base = [(base[0]*0.75)|0, (base[1]*0.75)|0, (base[2]*0.75)|0];
      const shade = Math.max(0.4, Math.min(1.0, 2.0 / (perpWallDist + 0.5)));
      const color = [(base[0]*shade)|0, (base[1]*shade)|0, (base[2]*shade)|0];

      ctx.fillStyle = `rgb(${color[0]},${color[1]},${color[2]})`;
      ctx.fillRect(x, drawStart, 1, drawEnd - drawStart + 1);

      if (!zBuf) zBuf = new Float32Array(W);
      zBuf[x] = perpWallDist;
    }

    // Sprites
    drawEnemies(zBuf); // replaced drawEnemy
    drawShots(zBuf);

    // HUD text (tile label)
    document.getElementById('hud').textContent = `${current_tile?.label || ''}`;

    // Blaster sway
    const turning = (rot !== 0);
    const moving  = (keys.has('KeyW') || keys.has('KeyS') || (MOBILE && (touchFlags.fwd || touchFlags.back)));
    let yawSign = 0;
    if (turning) yawSign = rot > 0 ? 1 : -1;
    if (turning || moving) { swayClock += dt; if (yawSign !== 0) lastYawSign = yawSign; }
    else { swayClock = 0; lastYawSign = 0; }
    drawBlaster(turning, moving, lastYawSign, swayClock);

    requestAnimationFrame(loop);
  }
  loop.lastNow = performance.now();

  function init() {
    W = canvas.width; H = canvas.height; HALF_H = (H/2)|0;
    zBuf = new Float32Array(W);
    start_new_run();
    requestAnimationFrame(loop);
  }
  init();

  function ensure_neighbors_visible() {
    const [t, d] = which_tile_contains(posX, posY);
    if (t && t !== current_tile && d !== null) enter_neighbor(d);
  }

  // Re-added: run reset / fresh start
  function start_new_run() {
    kills = 0; updateKillsUI();
    clears = 0; maxDifficulty = 0.0;
    enemies.length = 0;
    shots.length = 0;
    enemyShots.length = 0; // Clear enemy shots
    gameOverCountdown = -1;
    blockingWalls.clear(); // Clear all blocking walls

    current_tile = generate_tile(3);
    current_tile.kind = 'start';
    current_tile.open_sides = new Set([1,0,2]);
    current_tile.isStart = true;
    current_tile.label = 'start (no rear door)';
    current_tile.spawned = true; // force no spawn in start room

    generate_neighbors_for_center(current_tile, 3);
    prev_tile = null;
    rebuild_world(current_tile, prev_tile, null);

    const [ox, oy] = tile_positions.get(current_tile);
    posX = ox + TILE * 0.5;
    posY = oy + TILE * 0.5;
    dirX = 1.0; dirY = 0.0;
    planeX = 0.0; planeY = 0.66;
  }

  // Ensure first room visit spawns neighbors' enemies when entered
  // (spawn occurs on entering them, not now)
  </script>
</body>
</html>
