<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fixed Camera Base</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #111;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      #debug {
        position: fixed;
        top: 12px;
        right: 12px;
        padding: 8px 10px;
        background: rgba(0, 0, 0, 0.6);
        color: #e6e6e6;
        font: 12px/1.4 ui-monospace, "SFMono-Regular", Menlo, Consolas,
          "Liberation Mono", monospace;
        white-space: pre;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        pointer-events: none;
        z-index: 10;
      }
      #pickup-message {
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        color: #ffd84a;
        font: 54px/1.2 ui-monospace, "SFMono-Regular", Menlo, Consolas,
          "Liberation Mono", monospace;
        opacity: 0;
        pointer-events: none;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        z-index: 10;
      }
      #door-locked {
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        color: #ff3b3b;
        font: 54px/1.2 ui-monospace, "SFMono-Regular", Menlo, Consolas,
          "Liberation Mono", monospace;
        opacity: 0;
        pointer-events: none;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        z-index: 10;
      }
      #door-prompt {
        position: fixed;
        bottom: 24px;
        left: 50%;
        transform: translateX(-50%);
        color: #ffffff;
        font: 16px/1.2 ui-monospace, "SFMono-Regular", Menlo, Consolas,
          "Liberation Mono", monospace;
        opacity: 0;
        pointer-events: none;
        letter-spacing: 0.08em;
        z-index: 10;
      }
      #fade-overlay {
        position: fixed;
        inset: 0;
        background: #000;
        opacity: 0;
        pointer-events: none;
        z-index: 20;
      }
      #end-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #3dff74;
        font: 66px/1.2 ui-monospace, "SFMono-Regular", Menlo, Consolas,
          "Liberation Mono", monospace;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        opacity: 0;
        pointer-events: none;
        z-index: 21;
      }
    </style>
  </head>
  <body>
    <div id="pickup-message"></div>
    <div id="door-locked">The door is locked</div>
    <div id="door-prompt">(E)</div>
    <div id="debug">Loading...</div>
    <div id="fade-overlay"></div>
    <div id="end-message">Proof of concept complete</div>
    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        40,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.rotation.order = "YXZ";
      camera.up.set(0, 1, 0);
      const defaultCameraPreset = {
        position: new THREE.Vector3(8.89, 5.55, 8.46),
        rotation: new THREE.Euler(
          THREE.MathUtils.degToRad(-28.6),
          THREE.MathUtils.degToRad(45),
          0,
          "YXZ"
        ),
        fov: 59.7,
      };
      const quadrantCameraPresets = {
        1: {
          position: new THREE.Vector3(0.22, 4.77, 2.4),
          rotation: new THREE.Euler(
            THREE.MathUtils.degToRad(-33.1),
            THREE.MathUtils.degToRad(115.2),
            0,
            "YXZ"
          ),
          fov: 63.8,
        },
        2: defaultCameraPreset,
        3: defaultCameraPreset,
        4: defaultCameraPreset,
      };
      const cameraZones = [
        {
          key: "zone-1",
          minX: 2.05,
          maxX: 8.53,
          minZ: -10.0,
          maxZ: -3.76,
          preset: {
            position: new THREE.Vector3(7.03, 6.34, -5.07),
            rotation: new THREE.Euler(
              THREE.MathUtils.degToRad(-65.6),
              THREE.MathUtils.degToRad(39.8),
              0,
              "YXZ"
            ),
            fov: 59.7,
          },
        },
      ];
      let cameraYaw = 0;
      let cameraPitch = 0;

      function applyCameraPreset(preset) {
        camera.position.copy(preset.position);
        camera.rotation.set(preset.rotation.x, preset.rotation.y, 0);
        camera.fov = preset.fov;
        camera.updateProjectionMatrix();
        cameraYaw = camera.rotation.y;
        cameraPitch = camera.rotation.x;
      }

      applyCameraPreset(defaultCameraPreset);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);
      const debugHud = document.getElementById("debug");
      const pickupMessage = document.getElementById("pickup-message");
      const doorPrompt = document.getElementById("door-prompt");
      const doorLocked = document.getElementById("door-locked");
      const fadeOverlay = document.getElementById("fade-overlay");
      const endMessage = document.getElementById("end-message");

      const floorSize = 20;
      const halfSize = floorSize / 2;
      const hallwayOutline = [
        new THREE.Vector2(-halfSize, 0),
        new THREE.Vector2(-halfSize, halfSize),
        new THREE.Vector2(halfSize, halfSize),
        new THREE.Vector2(halfSize, -halfSize),
        new THREE.Vector2(0, -halfSize),
        new THREE.Vector2(0, 0),
      ];

      const floorShape = new THREE.Shape();
      hallwayOutline.forEach((point, index) => {
        const shapeX = point.x;
        const shapeY = -point.y;
        if (index === 0) {
          floorShape.moveTo(shapeX, shapeY);
        } else {
          floorShape.lineTo(shapeX, shapeY);
        }
      });
      floorShape.closePath();

      const floorGeometry = new THREE.ShapeGeometry(floorShape);
      floorGeometry.rotateX(-Math.PI / 2);
      const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x2d2d2d });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      scene.add(floor);

      const wallHeight = 9;
      const wallThickness = 0.4;
      const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x3a3a3a });
      const wallPoints = hallwayOutline;

      function addWall(start, end) {
        const dx = end.x - start.x;
        const dz = end.y - start.y;
        const length = Math.hypot(dx, dz);
        const wallGeometry = new THREE.BoxGeometry(
          length,
          wallHeight,
          wallThickness
        );
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        wall.position.set(
          (start.x + end.x) / 2,
          wallHeight / 2,
          (start.y + end.y) / 2
        );
        wall.rotation.y = Math.atan2(dz, dx);
        scene.add(wall);
      }

      for (let i = 0; i < wallPoints.length; i += 1) {
        const nextPoint = wallPoints[(i + 1) % wallPoints.length];
        addWall(wallPoints[i], nextPoint);
      }

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x2d2d2d, 0.7);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(6, 12, 6);
      scene.add(dirLight);

      const clock = new THREE.Clock();
      const keys = {
        w: false,
        a: false,
        s: false,
        d: false,
        e: false,
        arrowup: false,
        arrowdown: false,
        arrowleft: false,
        arrowright: false,
        k: false,
        l: false,
      };
      const moveSpeed = 3;
      const turnSpeed = THREE.MathUtils.degToRad(120);
      const moveDirection = new THREE.Vector3();
      const moveStep = new THREE.Vector3();
      const cameraForward = new THREE.Vector3();
      const cameraRight = new THREE.Vector3();
      const forwardVector = new THREE.Vector3(0, 0, -1);
      const cameraMoveSpeed = 6;
      const cameraRotateSpeed = THREE.MathUtils.degToRad(60);
      const cameraFovSpeed = 30;
      let currentCameraKey = null;
      let ePressed = false;
      let gameComplete = false;
      const fadeSpeed = 0.9;
      let fadeAlpha = 0;
      const player = new THREE.Group();
      player.position.set(-8.47, 0, 5.35);
      player.rotation.y = THREE.MathUtils.degToRad(271.7);
      scene.add(player);

      const keyPosition = new THREE.Vector3(5.07, 0, -7.85);
      const keyPickupRadius = 0.8;
      let keyObject = null;
      let keyCollected = false;
      const messageHold = 0.8;
      const messageFade = 2.5;
      let messageTimer = 0;
      let doorLockedTimer = 0;
      const doorPosition = new THREE.Vector3(-4.17, 0, 9.7);
      const doorPromptRadius = 2;
      let doorObject = null;

      const originMarker = new THREE.Mesh(
        new THREE.BoxGeometry(0.12, 0.12, 0.12),
        new THREE.MeshBasicMaterial({ color: 0xff3333 })
      );
      originMarker.position.set(0, 0.06, 0);
      player.add(originMarker);

      window.addEventListener("keydown", (event) => {
        const key = event.key.toLowerCase();
        if (key in keys) {
          keys[key] = true;
          if (key === "e" && !event.repeat) {
            ePressed = true;
          }
          event.preventDefault();
        }
      });

      window.addEventListener("keyup", (event) => {
        const key = event.key.toLowerCase();
        if (key in keys) {
          keys[key] = false;
          event.preventDefault();
        }
      });

      const loader = new GLTFLoader();
      const modelMaterial = new THREE.MeshStandardMaterial({ color: 0x2ecc71 });
      loader.load(
        "./ChrosGreenfield.glb",
        (gltf) => {
          gltf.scene.traverse((child) => {
            if (child.isMesh) {
              child.material = modelMaterial;
            }
          });
          gltf.scene.scale.setScalar(1 / 3);
          const bounds = new THREE.Box3().setFromObject(gltf.scene);
          gltf.scene.position.y += -bounds.min.y;
          player.add(gltf.scene);
        },
        undefined,
        (error) => {
          console.error("Failed to load ChrosGreenfield.glb:", error);
        }
      );

      const keyMaterial = new THREE.MeshStandardMaterial({ color: 0xffd84a });
      loader.load(
        "./Key.glb",
        (gltf) => {
          gltf.scene.traverse((child) => {
            if (child.isMesh) {
              child.material = keyMaterial;
            }
          });
          keyObject = gltf.scene;
          keyObject.scale.setScalar(1 / 3);
          keyObject.position.set(keyPosition.x, 0, keyPosition.z);
          const bounds = new THREE.Box3().setFromObject(keyObject);
          keyObject.position.y = -bounds.min.y;
          scene.add(keyObject);
        },
        undefined,
        (error) => {
          console.error("Failed to load Key.glb:", error);
        }
      );

      const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x6b4a2b });
      loader.load(
        "./Door.glb",
        (gltf) => {
          gltf.scene.traverse((child) => {
            if (child.isMesh) {
              child.material = doorMaterial;
            }
          });
          doorObject = gltf.scene;
          doorObject.scale.setScalar(1 / 3);
          doorObject.position.copy(doorPosition);
          const bounds = new THREE.Box3().setFromObject(doorObject);
          doorObject.position.y = doorPosition.y - bounds.min.y;
          scene.add(doorObject);
        },
        undefined,
        (error) => {
          console.error("Failed to load Door.glb:", error);
        }
      );

      function isInsideHallway(x, z) {
        let inside = false;
        for (
          let i = 0, j = hallwayOutline.length - 1;
          i < hallwayOutline.length;
          j = i++
        ) {
          const xi = hallwayOutline[i].x;
          const zi = hallwayOutline[i].y;
          const xj = hallwayOutline[j].x;
          const zj = hallwayOutline[j].y;
          const intersects =
            (zi > z) !== (zj > z) &&
            x < ((xj - xi) * (z - zi)) / (zj - zi) + xi;
          if (intersects) {
            inside = !inside;
          }
        }
        return inside;
      }

      function getQuadrantForPosition(x, z) {
        if (x < 0 && z >= 0) {
          return 1;
        }
        if (x >= 0 && z >= 0) {
          return 2;
        }
        if (x >= 0 && z < 0) {
          return 3;
        }
        return 4;
      }

      function getCameraPresetForPosition(x, z) {
        for (const zone of cameraZones) {
          if (
            x >= zone.minX &&
            x <= zone.maxX &&
            z >= zone.minZ &&
            z <= zone.maxZ
          ) {
            return { key: zone.key, preset: zone.preset };
          }
        }
        const quadrant = getQuadrantForPosition(x, z);
        return {
          key: `quadrant-${quadrant}`,
          preset: quadrantCameraPresets[quadrant],
        };
      }

      function updateCameraByQuadrant(force = false) {
        const cameraControlActive =
          keys.k ||
          keys.l ||
          keys.arrowup ||
          keys.arrowdown ||
          keys.arrowleft ||
          keys.arrowright;
        if (!force && cameraControlActive) {
          return;
        }
        const selection = getCameraPresetForPosition(
          player.position.x,
          player.position.z
        );
        if (force || selection.key !== currentCameraKey) {
          currentCameraKey = selection.key;
          applyCameraPreset(selection.preset);
        }
      }

      function showPickupMessage(text) {
        pickupMessage.textContent = text;
        pickupMessage.style.opacity = "1";
        messageTimer = messageHold + messageFade;
      }

      function updatePickupMessage(delta) {
        if (messageTimer <= 0) {
          return;
        }
        messageTimer = Math.max(messageTimer - delta, 0);
        const alpha =
          messageTimer > messageFade ? 1 : messageTimer / messageFade;
        pickupMessage.style.opacity = alpha.toFixed(2);
      }

      function showDoorLockedMessage() {
        doorLocked.style.opacity = "1";
        doorLockedTimer = messageHold + messageFade;
      }

      function updateDoorLockedMessage(delta) {
        if (doorLockedTimer <= 0) {
          return;
        }
        doorLockedTimer = Math.max(doorLockedTimer - delta, 0);
        const alpha =
          doorLockedTimer > messageFade ? 1 : doorLockedTimer / messageFade;
        doorLocked.style.opacity = alpha.toFixed(2);
      }

      function checkKeyPickup() {
        if (keyCollected || !keyObject) {
          return;
        }
        const dx = player.position.x - keyObject.position.x;
        const dz = player.position.z - keyObject.position.z;
        const distance = Math.hypot(dx, dz);
        if (distance <= keyPickupRadius) {
          keyCollected = true;
          keyObject.visible = false;
          showPickupMessage("aquired key");
        }
      }

      function startCompletion() {
        if (gameComplete) {
          return;
        }
        gameComplete = true;
        fadeAlpha = 0;
        fadeOverlay.style.opacity = "0";
        endMessage.style.opacity = "0";
      }

      function updateCompletion(delta) {
        if (!gameComplete) {
          return;
        }
        fadeAlpha = Math.min(1, fadeAlpha + fadeSpeed * delta);
        const alpha = fadeAlpha.toFixed(2);
        fadeOverlay.style.opacity = alpha;
        endMessage.style.opacity = alpha;
      }

      function updateDoorInteraction() {
        if (!doorObject) {
          doorPrompt.style.opacity = "0";
          doorLocked.style.opacity = "0";
          doorLockedTimer = 0;
          ePressed = false;
          return;
        }

        const dx = player.position.x - doorPosition.x;
        const dz = player.position.z - doorPosition.z;
        const inRange = Math.hypot(dx, dz) <= doorPromptRadius;

        if (gameComplete) {
          doorPrompt.style.opacity = "0";
          doorLocked.style.opacity = "0";
          doorLockedTimer = 0;
          ePressed = false;
          return;
        }

        doorPrompt.style.opacity = inRange ? "1" : "0";

        if (inRange && ePressed && keyCollected) {
          startCompletion();
        } else if (inRange && ePressed && !keyCollected) {
          showDoorLockedMessage();
        }

        ePressed = false;
      }

      function updatePlayer(delta) {
        if (keys.a) {
          player.rotation.y += turnSpeed * delta;
        }
        if (keys.d) {
          player.rotation.y -= turnSpeed * delta;
        }

        let move = 0;
        if (keys.w) {
          move += moveSpeed * delta;
        }
        if (keys.s) {
          move -= moveSpeed * delta;
        }

        if (move !== 0) {
          moveDirection.copy(forwardVector).applyQuaternion(player.quaternion);
          moveDirection.y = 0;
          moveDirection.normalize();
          moveStep.copy(moveDirection).multiplyScalar(move);
          const nextX = player.position.x + moveStep.x;
          const nextZ = player.position.z + moveStep.z;

          if (isInsideHallway(nextX, nextZ)) {
            player.position.set(nextX, player.position.y, nextZ);
          } else {
            const canMoveX = isInsideHallway(nextX, player.position.z);
            const canMoveZ = isInsideHallway(player.position.x, nextZ);
            if (canMoveX) {
              player.position.x = nextX;
            }
            if (canMoveZ) {
              player.position.z = nextZ;
            }
          }
        }
      }

      function updateCamera(delta) {
        if (keys.k) {
          let yaw = 0;
          let pitch = 0;
          if (keys.arrowleft) {
            yaw += cameraRotateSpeed * delta;
          }
          if (keys.arrowright) {
            yaw -= cameraRotateSpeed * delta;
          }
          if (keys.arrowup) {
            pitch += cameraRotateSpeed * delta;
          }
          if (keys.arrowdown) {
            pitch -= cameraRotateSpeed * delta;
          }
          cameraYaw += yaw;
          cameraPitch = THREE.MathUtils.clamp(
            cameraPitch + pitch,
            -1.35,
            1.35
          );
          camera.rotation.set(cameraPitch, cameraYaw, 0);
          return;
        }

        if (keys.l) {
          if (keys.arrowup) {
            camera.position.y += cameraMoveSpeed * delta;
          }
          if (keys.arrowdown) {
            camera.position.y -= cameraMoveSpeed * delta;
          }
          if (keys.arrowleft) {
            camera.fov = Math.max(20, camera.fov - cameraFovSpeed * delta);
            camera.updateProjectionMatrix();
          }
          if (keys.arrowright) {
            camera.fov = Math.min(100, camera.fov + cameraFovSpeed * delta);
            camera.updateProjectionMatrix();
          }
          return;
        }

        let forward = 0;
        let strafe = 0;

        if (keys.arrowup) {
          forward += 1;
        }
        if (keys.arrowdown) {
          forward -= 1;
        }
        if (keys.arrowleft) {
          strafe -= 1;
        }
        if (keys.arrowright) {
          strafe += 1;
        }

        if (forward !== 0 || strafe !== 0) {
          cameraForward.set(0, 0, -1).applyQuaternion(camera.quaternion);
          cameraForward.y = 0;
          cameraForward.normalize();
          cameraRight.set(1, 0, 0).applyQuaternion(camera.quaternion);
          cameraRight.y = 0;
          cameraRight.normalize();
          camera.position.addScaledVector(
            cameraForward,
            forward * cameraMoveSpeed * delta
          );
          camera.position.addScaledVector(
            cameraRight,
            strafe * cameraMoveSpeed * delta
          );
        }
      }

      function updateDebugHud() {
        const p = player.position;
        const c = camera.position;
        const pRot = player.rotation;
        const cRot = camera.rotation;
        const pRotDeg = {
          x: THREE.MathUtils.radToDeg(pRot.x),
          y: THREE.MathUtils.radToDeg(pRot.y),
          z: THREE.MathUtils.radToDeg(pRot.z),
        };
        const cRotDeg = {
          x: THREE.MathUtils.radToDeg(cRot.x),
          y: THREE.MathUtils.radToDeg(cRot.y),
          z: THREE.MathUtils.radToDeg(cRot.z),
        };
        debugHud.textContent =
          `Player: ${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)}\n` +
          `Player Rot: ${pRotDeg.x.toFixed(1)}, ${pRotDeg.y.toFixed(
            1
          )}, ${pRotDeg.z.toFixed(1)}\n` +
          `Camera: ${c.x.toFixed(2)}, ${c.y.toFixed(2)}, ${c.z.toFixed(2)}\n` +
          `Camera Rot: ${cRotDeg.x.toFixed(1)}, ${cRotDeg.y.toFixed(
            1
          )}, ${cRotDeg.z.toFixed(1)}\n` +
          `FOV: ${camera.fov.toFixed(1)}`;
      }

      function render() {
        const delta = clock.getDelta();
        if (!gameComplete) {
          updatePlayer(delta);
          checkKeyPickup();
          updateCameraByQuadrant();
          updateCamera(delta);
        }
        updateDoorInteraction();
        updatePickupMessage(delta);
        updateDoorLockedMessage(delta);
        updateCompletion(delta);
        updateDebugHud();
        renderer.render(scene, camera);
        requestAnimationFrame(render);
      }

      updateCameraByQuadrant(true);
      render();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
